<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Unimate - Connected Mode</title>
    <!-- Add Three.js library with integrity hash to avoid MIME issues -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"
        integrity="sha512-dLxUelApnYxpLt6K2iomGngnHO83iUvZytA3YjDUCjT0HDOHKXnVYdf3hU4JjM8uEhxf9nD1/ey98U3t2vZ0qQ=="
        crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <style>
        /* Inline all necessary styles */
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background-color: #f3f4f6;
            margin: 0;
            padding: 0;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 1.5rem;
        }

        .header {
            background-color: white;
            border-radius: 0.5rem;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            padding: 1.5rem;
            margin-bottom: 1.5rem;
        }

        .header h1 {
            font-size: 1.875rem;
            font-weight: bold;
            margin-bottom: 1rem;
            color: #111827;
        }

        .header p {
            color: #6b7280;
            margin-bottom: 1rem;
        }

        .content-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 1.5rem;
        }

        @media (min-width: 768px) {
            .content-grid {
                grid-template-columns: 1fr 1fr;
            }
        }

        .timetable-container,
        .map-container {
            background-color: white;
            border-radius: 0.5rem;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            padding: 1.5rem;
        }

        .timetable-container h2,
        .map-container h2 {
            font-size: 1.25rem;
            font-weight: bold;
            margin-bottom: 1rem;
            color: #111827;
        }

        .timetable {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        #map-container {
            height: 400px;
            width: 100%;
            background-color: #f9fafb;
            border-radius: 0.375rem;
            overflow: hidden;
        }

        .event {
            padding: 1rem;
            border: 1px solid #e5e7eb;
            border-radius: 0.5rem;
            cursor: pointer;
            transition: background-color 0.2s;
            margin-bottom: 0.75rem;
        }

        .event:hover {
            background-color: #f9fafb;
        }

        .event-class {
            border-left: 4px solid #3b82f6;
        }

        .event-exam {
            border-left: 4px solid #f97316;
        }

        .event-urgent {
            border: 1px solid #ef4444;
            background-color: #fef2f2;
        }

        .event-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
        }

        .event-title-container {
            flex: 1;
        }

        .event-title-row {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 0.25rem;
        }

        .event-title {
            font-weight: bold;
            font-size: 1.125rem;
            color: #111827;
        }

        .event-type {
            padding: 0.25rem 0.5rem;
            border-radius: 0.25rem;
            font-size: 0.75rem;
            font-weight: 600;
        }

        .event-type-class {
            background-color: #dbeafe;
            color: #1e40af;
        }

        .event-type-exam {
            background-color: #ffedd5;
            color: #9a3412;
        }

        .event-course {
            font-size: 0.875rem;
            color: #4b5563;
            margin-bottom: 0.25rem;
        }

        .event-time {
            font-size: 0.875rem;
            color: #6b7280;
        }

        .event-right {
            text-align: right;
        }

        .event-lecturer {
            font-size: 0.875rem;
            font-weight: 500;
            color: #4b5563;
        }

        .event-urgent-badge {
            display: inline-block;
            background-color: #ef4444;
            color: white;
            font-size: 0.75rem;
            padding: 0.125rem 0.5rem;
            border-radius: 0.25rem;
            margin-top: 0.25rem;
        }

        .button {
            display: block;
            width: 100%;
            margin-top: 1rem;
            padding: 0.5rem 1rem;
            color: #1f2937;
            font-weight: 600;
            border: none;
            border-radius: 0.375rem;
            cursor: pointer;
            font-size: 0.875rem;
            transition: background-color 0.2s;
            text-align: center;
        }

        .button-primary {
            background-color: #3b82f6;
            color: white;
        }

        .button-primary:hover {
            background-color: #2563eb;
        }

        .button-secondary {
            background-color: #f3f4f6;
        }

        .button-secondary:hover {
            background-color: #e5e7eb;
        }

        /* Login screen styles */
        .login-screen {
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .login-container {
            background-color: white;
            padding: 2rem;
            border-radius: 0.5rem;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            width: 100%;
            max-width: 24rem;
        }

        .login-title {
            font-size: 1.5rem;
            font-weight: bold;
            margin-bottom: 1.5rem;
            text-align: center;
            color: #111827;
        }

        .login-subtitle {
            text-align: center;
            color: #6b7280;
            margin-bottom: 1.5rem;
        }

        .form-group {
            margin-bottom: 1rem;
        }

        .form-input {
            display: block;
            width: 100%;
            padding: 0.5rem 0.75rem;
            border: 1px solid #d1d5db;
            border-radius: 0.375rem;
            font-size: 0.875rem;
            box-sizing: border-box;
        }

        .form-input:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }

        .status-message {
            padding: 0.75rem;
            border-radius: 0.375rem;
            margin-bottom: 1rem;
            font-size: 0.875rem;
        }

        .status-error {
            background-color: #fee2e2;
            color: #b91c1c;
        }

        .status-success {
            background-color: #d1fae5;
            color: #065f46;
        }

        .navbar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }

        .username-display {
            font-weight: 500;
            color: #4b5563;
        }

        .logout-link {
            color: #6b7280;
            text-decoration: none;
            cursor: pointer;
        }

        .logout-link:hover {
            color: #111827;
        }

        /* Utility classes */
        .hidden {
            display: none !important;
        }

        @media print {
            body {
                background-color: white;
            }

            .container {
                padding: 0;
            }

            .header {
                box-shadow: none;
                padding: 1rem 0;
                margin-bottom: 1rem;
            }

            .timetable-container {
                box-shadow: none;
                padding: 0;
            }

            .event {
                break-inside: avoid;
                page-break-inside: avoid;
            }

            .button,
            .navbar,
            .map-container {
                display: none;
            }
        }
    </style>
</head>

<body>
    <!-- Login Screen -->
    <div id="login-screen" class="login-screen">
        <div class="login-container">
            <h1 class="login-title">Unimate</h1>
            <p class="login-subtitle">Tap your ID card or login with credentials</p>
            <div id="login-status" class="hidden status-message"></div>
            <form id="login-form">
                <div class="form-group">
                    <input type="text" id="username" class="form-input" placeholder="Username" required>
                </div>
                <div class="form-group">
                    <input type="password" id="password" class="form-input" placeholder="Password" required>
                </div>
                <button type="submit" class="button button-primary">Login</button>
            </form>
            <button id="demo-mode-btn" class="button button-secondary" style="margin-top: 0.5rem;">
                Try Demo Mode
            </button>
        </div>
    </div>

    <!-- Dashboard Screen -->
    <div id="dashboard" class="hidden">
        <div class="container">
            <div class="header">
                <div class="navbar">
                    <h1>Unimate</h1>
                    <div>
                        <span id="username-display" class="username-display"></span>
                        <a id="logout-btn" class="logout-link" style="margin-left: 1rem;">Logout</a>
                    </div>
                </div>
                <p id="connection-status">Connected to Unimate backend</p>
            </div>

            <div class="content-grid">
                <!-- Timetable Section -->
                <div class="timetable-container">
                    <h2>Your Timetable</h2>
                    <div id="timetable" class="space-y-4"></div>
                </div>

                <!-- 3D Map Section -->
                <div class="map-container">
                    <h2>3D Map</h2>
                    <div id="map-container"></div>
                    <p class="text-sm text-gray-500 mt-2">Click on a timetable event to show the route to your class.
                    </p>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let isConnectedMode = false;
        let authToken = null;
        let currentUsername = '';
        let mapScene = null;
        let mapCamera = null;
        let mapRenderer = null;
        let currentRoute = null;

        // Sample demo event data
        const demoEvents = [
            {
                id: 1,
                title: "ENGGEN205 Lecture",
                event_type: "class",
                course: { code: "ENGGEN205", name: "Engineering Mechanics" },
                room: { building: "ENG", number: "340" },
                start_time: new Date().toISOString(),
                end_time: new Date(Date.now() + 3600000).toISOString(), // 1 hour from now
                lecturer: "Dr. Smith",
                is_urgent: false
            },
            {
                id: 2,
                title: "STATS100 Mid-term Exam",
                event_type: "exam",
                course: { code: "STATS100", name: "Statistics" },
                room: { building: "ENG", number: "401" },
                start_time: new Date(Date.now() + 86400000).toISOString(), // Tomorrow
                end_time: new Date(Date.now() + 86400000 + 7200000).toISOString(), // Tomorrow + 2 hours
                lecturer: "N/A",
                is_urgent: true
            },
            {
                id: 3,
                title: "COMPSCI101 Lab",
                event_type: "class",
                course: { code: "COMPSCI101", name: "Computer Science" },
                room: { building: "SCI", number: "201" },
                start_time: new Date(Date.now() + 2 * 86400000).toISOString(), // 2 days from now
                end_time: new Date(Date.now() + 2 * 86400000 + 5400000).toISOString(), // 2 days + 1.5 hours
                lecturer: "Prof. Ada",
                is_urgent: false
            }
        ];

        // Sample route data for demo mode
        const demoRoutes = {
            "ENG340": [
                [0, 0, 0],
                [2, 0, 1],
                [4, 0, 2],
                [4, 1, 3],
                [5, 1, 4]
            ],
            "ENG401": [
                [0, 0, 0],
                [2, 0, 1],
                [4, 0, 2],
                [4, 1, 3],
                [4, 2, 4],
                [6, 2, 5]
            ],
            "SCI201": [
                [0, 0, 0],
                [-2, 0, 1],
                [-4, 0, 2],
                [-4, 1, 3]
            ]
        };

        // Format date to display
        function formatDate(date) {
            const options = { weekday: 'short', month: 'short', day: 'numeric' };
            return new Date(date).toLocaleDateString(undefined, options);
        }

        // Format time to display
        function formatTime(date) {
            const options = { hour: '2-digit', minute: '2-digit' };
            return new Date(date).toLocaleTimeString(undefined, options);
        }

        // Show status message
        function showStatus(message, isError = false) {
            const statusEl = document.getElementById('login-status');
            statusEl.textContent = message;
            statusEl.className = isError ? 'status-message status-error' : 'status-message status-success';
            statusEl.classList.remove('hidden');
        }

        // Hide status message
        function hideStatus() {
            const statusEl = document.getElementById('login-status');
            statusEl.classList.add('hidden');
        }

        // Initialize 3D Map
        function initMap() {
            console.log("Initializing 3D map");
            const container = document.getElementById('map-container');
            if (!container) {
                console.error("Map container not found!");
                return;
            }

            // Scene setup
            mapScene = new THREE.Scene();
            mapCamera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
            mapRenderer = new THREE.WebGLRenderer({ antialias: true });
            mapRenderer.setSize(container.clientWidth, container.clientHeight);
            mapRenderer.setClearColor(0xf9fafb); // Light gray background
            container.innerHTML = '';
            container.appendChild(mapRenderer.domElement);

            // Add ambient light
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            mapScene.add(ambientLight);

            // Add directional light
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 10, 7);
            mapScene.add(directionalLight);

            // Add a simple floor
            const floorGeometry = new THREE.PlaneGeometry(20, 20, 10, 10);
            const floorMaterial = new THREE.MeshStandardMaterial({
                color: 0xe5e7eb,
                wireframe: false,
                flatShading: true
            });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.position.y = -0.1;
            mapScene.add(floor);

            // Add simple building representation
            addSimpleBuilding("ENG", 2, 4, 0);
            addSimpleBuilding("SCI", -4, 2, 0);
            addSimpleBuilding("LIB", 0, 0, 0);

            // Position camera
            mapCamera.position.set(10, 10, 10);
            mapCamera.lookAt(0, 0, 0);

            // Handle window resize
            window.addEventListener('resize', () => {
                if (!mapRenderer || !mapCamera) return;
                mapCamera.aspect = container.clientWidth / container.clientHeight;
                mapCamera.updateProjectionMatrix();
                mapRenderer.setSize(container.clientWidth, container.clientHeight);
            });

            // Animation loop
            function animate() {
                if (!mapRenderer) return;
                requestAnimationFrame(animate);
                mapRenderer.render(mapScene, mapCamera);
            }
            animate();
            console.log("3D map initialized successfully");
        }

        // Add a simple building to the map
        function addSimpleBuilding(name, x, z, y = 0) {
            const height = 4;
            const width = 4;
            const depth = 4;

            // Building geometry and material
            const geometry = new THREE.BoxGeometry(width, height, depth);
            const material = new THREE.MeshStandardMaterial({
                color: name === "ENG" ? 0x3b82f6 : name === "SCI" ? 0x10b981 : 0x93c5fd,
                transparent: true,
                opacity: 0.7
            });

            const building = new THREE.Mesh(geometry, material);
            building.position.set(x, y + height / 2, z);
            mapScene.add(building);

            // Add text label
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 256;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = 'white';
            ctx.font = 'Bold 40px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(name, 128, 128);

            const texture = new THREE.CanvasTexture(canvas);
            const labelMaterial = new THREE.SpriteMaterial({ map: texture });
            const label = new THREE.Sprite(labelMaterial);
            label.position.set(x, y + height + 0.5, z);
            label.scale.set(2, 1, 1);
            mapScene.add(label);
        }

        // Fit camera to display the route
        function fitCameraToRoute(points) {
            if (!points || points.length === 0) return;

            // Calculate the center and bounding box of the route
            const center = new THREE.Vector3();
            points.forEach(point => {
                center.add(point);
            });
            center.divideScalar(points.length);

            // Position camera to look at center from an angle
            const offset = new THREE.Vector3(5, 5, 5);
            mapCamera.position.copy(center).add(offset);
            mapCamera.lookAt(center);
        }

        // Create a complete route between all classes in sequence
        function createCompleteRoute(events) {
            console.log("Creating complete route for", events.length, "events");

            // Sort events by start time
            const sortedEvents = [...events].sort((a, b) =>
                new Date(a.start_time) - new Date(b.start_time)
            );

            // Skip if no events or only one event
            if (sortedEvents.length <= 1) {
                console.log("Not enough events to create a route");
                return;
            }

            // Collect all room codes in sequence
            const rooms = sortedEvents
                .filter(event => event.room && event.room.building)
                .map(event => `${event.room.building}${event.room.number}`);

            console.log("Route sequence:", rooms);
            console.log("Events in sequence:", sortedEvents.map(e => e.title));

            // Create a combined route
            let combinedRoute = [];

            if (isConnectedMode && authToken) {
                // In connected mode, fetch all routes and combine them
                fetchAllRoutes(sortedEvents)
                    .then(routes => {
                        if (routes && routes.length > 0) {
                            console.log("Using real routes from API");
                            visualizeMultipleRoutes(routes, sortedEvents);
                        } else {
                            // Fall back to demo routes
                            console.log("API routes failed, using demo routes");
                            createDemoMultiRoute(sortedEvents);
                        }
                    })
                    .catch(error => {
                        console.error("Error fetching routes:", error);
                        // Fall back to demo routes
                        console.log("Error with API routes, using demo routes");
                        createDemoMultiRoute(sortedEvents);
                    });
            } else {
                // In demo mode, use predefined routes
                console.log("Using demo routes (not connected to API)");
                createDemoMultiRoute(sortedEvents);
            }
        }

        // Create a demo multi-route between events
        function createDemoMultiRoute(events) {
            // Create points for each location
            let allPoints = [];
            let colors = [];
            const markerPositions = [];
            const markerLabels = [];

            // Start at kiosk point
            const startPoint = [0, 0, 0];
            allPoints.push(startPoint);
            markerPositions.push(new THREE.Vector3(startPoint[0], startPoint[2] || 0.1, startPoint[1]));
            markerLabels.push("START");

            // For each event, create a route to its location
            for (let i = 0; i < events.length; i++) {
                const event = events[i];
                if (!event.room) continue;

                const roomCode = `${event.room.building}${event.room.number}`;
                let route = getDemoRoute(roomCode);

                if (i > 0) {
                    // Remove the first point to avoid duplicating positions
                    route = route.slice(1);
                }

                // Add route points
                allPoints = allPoints.concat(route);

                // Add event location marker
                const eventPoint = route[route.length - 1];
                markerPositions.push(new THREE.Vector3(eventPoint[0], eventPoint[2] || 0.1, eventPoint[1]));
                markerLabels.push(`${i + 1}: ${event.course?.code || 'Class'}`);

                // Add this route's color (different color for each segment)
                const segmentColor = getColorForSegment(i);
                for (let j = 0; j < route.length; j++) {
                    colors.push(segmentColor);
                }
            }

            visualizeMultiRoute(allPoints, colors, markerPositions, markerLabels);
        }

        // Get color for route segment
        function getColorForSegment(index) {
            const colors = [
                0xff3333, // red
                0x3366ff, // blue
                0x33cc33, // green
                0xff9900, // orange
                0x9933ff  // purple
            ];
            return colors[index % colors.length];
        }

        // Visualize a multi-segment route
        function visualizeMultiRoute(points, colors, markerPositions, markerLabels) {
            console.log("Visualizing route with", points.length, "points and", markerPositions.length, "markers");
            console.log("Marker labels:", markerLabels);

            // Clear existing route
            clearRoute();

            if (!points || points.length < 2) {
                console.warn('Not enough points for route');
                return;
            }

            // Create a group for all route objects
            currentRoute = new THREE.Group();

            // Create points for the route
            const routePoints = points.map(coords =>
                new THREE.Vector3(coords[0], coords[2] || 0.1, coords[1])
            );

            // Create line segments
            const lineGeometry = new THREE.BufferGeometry().setFromPoints(routePoints);
            const lineMaterial = new THREE.LineBasicMaterial({ color: 0xff3333, linewidth: 3 });
            const routeLine = new THREE.Line(lineGeometry, lineMaterial);
            currentRoute.add(routeLine);

            // Add markers for each position
            const markerGeometry = new THREE.SphereGeometry(0.2, 16, 16);

            markerPositions.forEach((position, index) => {
                // Different color for start, middle, and end points
                let markerColor;
                if (index === 0) {
                    markerColor = 0x00ff00; // Green for start
                } else if (index === markerPositions.length - 1) {
                    markerColor = 0xff0000; // Red for end
                } else {
                    markerColor = 0xffcc00; // Yellow for intermediate points
                }

                const markerMaterial = new THREE.MeshBasicMaterial({ color: markerColor });
                const marker = new THREE.Mesh(markerGeometry, markerMaterial);
                marker.position.copy(position);
                currentRoute.add(marker);

                // Add text label
                addTextLabel(position, markerLabels[index]);
            });

            // Add the route group to the scene
            mapScene.add(currentRoute);

            // Adjust camera to see the entire route
            fitCameraToRoute(routePoints);
        }

        // Add text label above a position
        function addTextLabel(position, text) {
            if (!text) return;

            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 128;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = 'white';
            ctx.font = 'Bold 24px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(text, 128, 64);

            const texture = new THREE.CanvasTexture(canvas);
            const labelMaterial = new THREE.SpriteMaterial({ map: texture });
            const label = new THREE.Sprite(labelMaterial);
            label.position.set(position.x, position.y + 0.5, position.z);
            label.scale.set(1.5, 0.75, 1);
            currentRoute.add(label);
        }

        // Fetch all routes between events
        async function fetchAllRoutes(events) {
            if (!isConnectedMode || !authToken || events.length <= 1) {
                return null;
            }

            try {
                const routes = [];
                let from = 'kiosk-1'; // Start from kiosk

                // For each event, get route from previous location
                for (const event of events) {
                    if (!event.room) continue;

                    const to = `${event.room.building}${event.room.number}`;

                    const response = await fetch(`/api/route/?from=${from}&to=${to}`, {
                        headers: {
                            'Authorization': `Bearer ${authToken}`
                        }
                    });

                    if (!response.ok) {
                        throw new Error(`API returned ${response.status}`);
                    }

                    const routeData = await response.json();

                    if (routeData && routeData.features && routeData.features.length > 0) {
                        routes.push(routeData.features[0].geometry.coordinates);
                    }

                    // The destination becomes the origin for the next segment
                    from = to;
                }

                return routes;
            } catch (error) {
                console.error('Error fetching routes:', error);
                return null;
            }
        }

        // Visualize multiple routes between events
        function visualizeMultipleRoutes(routes, events) {
            // Combine all routes into one
            let allPoints = [];
            let colors = [];
            const markerPositions = [];
            const markerLabels = [];

            // Add start marker
            const firstRoute = routes[0];
            if (firstRoute && firstRoute.length > 0) {
                const startPoint = firstRoute[0];
                markerPositions.push(new THREE.Vector3(startPoint[0], startPoint[2] || 0.1, startPoint[1]));
                markerLabels.push("START");
            }

            // Process each route
            routes.forEach((route, i) => {
                if (!route || route.length < 2) return;

                // If not first route, remove first point to avoid duplicate
                const routePoints = i > 0 ? route.slice(1) : route;

                // Add to all points
                allPoints = allPoints.concat(routePoints);

                // Add this route's color
                const segmentColor = getColorForSegment(i);
                for (let j = 0; j < routePoints.length; j++) {
                    colors.push(segmentColor);
                }

                // Add event marker at the end of the route
                const endPoint = route[route.length - 1];
                markerPositions.push(new THREE.Vector3(endPoint[0], endPoint[2] || 0.1, endPoint[1]));
                markerLabels.push(`${i + 1}: ${events[i].course?.code || 'Class'}`);
            });

            visualizeMultiRoute(allPoints, colors, markerPositions, markerLabels);
        }

        // Handle event click to show route
        function showEventDetails(event) {
            // Show event details alert
            alert(`${event.title}\nLocation: ${event.room ? `${event.room.building} ${event.room.number}` : 'TBA'}\nTime: ${formatDate(event.start_time)} ${formatTime(event.start_time)} - ${formatTime(event.end_time)}\nLecturer: ${event.lecturer || 'N/A'}`);
        }

        // Get demo route for room
        function getDemoRoute(roomCode) {
            // Try exact match
            if (demoRoutes[roomCode]) return demoRoutes[roomCode];

            // Try building match
            for (const key in demoRoutes) {
                if (roomCode.includes(key.substring(0, 3))) {
                    return demoRoutes[key];
                }
            }

            // Default route if no match
            return demoRoutes["ENG340"];
        }

        // Fetch route from API
        async function fetchRoute(from, to) {
            if (!isConnectedMode || !authToken) {
                return null;
            }

            try {
                const response = await fetch(`/api/route/?from=${from}&to=${to}`, {
                    headers: {
                        'Authorization': `Bearer ${authToken}`
                    }
                });

                if (!response.ok) {
                    throw new Error(`API returned ${response.status}`);
                }

                const routeData = await response.json();

                if (routeData && routeData.features && routeData.features.length > 0) {
                    const coordinates = routeData.features[0].geometry.coordinates;
                    visualizeRoute(coordinates);
                    return coordinates;
                } else {
                    throw new Error('Invalid route data format');
                }
            } catch (error) {
                console.error('Error fetching route:', error);
                return null;
            }
        }

        // Handle login form submission
        document.getElementById('login-form').addEventListener('submit', async function (e) {
            e.preventDefault();

            const username = document.getElementById('username').value;
            const password = document.getElementById('password').value;

            try {
                showStatus('Logging in...', false);

                const response = await fetch('/api/login/', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ username, password })
                });

                if (!response.ok) {
                    throw new Error('Invalid credentials');
                }

                const data = await response.json();

                if (data.access) {
                    // Store token
                    authToken = data.access;
                    currentUsername = username;
                    isConnectedMode = true;

                    // Store token for persistence
                    localStorage.setItem('unimate_token', authToken);
                    localStorage.setItem('unimate_username', currentUsername);

                    // Show dashboard
                    showDashboard();

                    // Fetch real data
                    fetchEvents();
                } else {
                    throw new Error('No access token received');
                }
            } catch (error) {
                console.error('Login error:', error);
                showStatus('Login failed: ' + error.message, true);
            }
        });

        // Demo mode button
        document.getElementById('demo-mode-btn').addEventListener('click', function () {
            isConnectedMode = false;
            currentUsername = 'Demo User';
            showDashboard();
            renderTimetable(demoEvents);
        });

        // Logout button
        document.getElementById('logout-btn').addEventListener('click', function () {
            authToken = null;
            currentUsername = '';
            localStorage.removeItem('unimate_token');
            localStorage.removeItem('unimate_username');
            document.getElementById('dashboard').classList.add('hidden');
            document.getElementById('login-screen').classList.remove('hidden');
            hideStatus();
            document.getElementById('username').value = '';
            document.getElementById('password').value = '';
            clearRoute();
        });

        // Show dashboard
        function showDashboard() {
            document.getElementById('login-screen').classList.add('hidden');
            document.getElementById('dashboard').classList.remove('hidden');
            document.getElementById('username-display').textContent = currentUsername;
            document.getElementById('connection-status').textContent = isConnectedMode ?
                'Connected to Unimate backend' : 'Demo mode (not connected to backend)';

            // Initialize 3D map
            initMap();
        }

        // Fetch events from API
        async function fetchEvents() {
            if (!authToken) {
                console.warn('No auth token available for API request');
                return;
            }

            try {
                const response = await fetch('/api/events/', {
                    headers: {
                        'Authorization': `Bearer ${authToken}`
                    }
                });

                if (!response.ok) {
                    throw new Error(`API returned ${response.status}`);
                }

                const events = await response.json();
                renderTimetable(events);
            } catch (error) {
                console.error('Error fetching events:', error);
                // Fall back to demo data
                renderTimetable(demoEvents);
            }
        }

        // Render timetable
        function renderTimetable(events) {
            console.log("Rendering timetable with", events ? events.length : 0, "events");

            const timetable = document.getElementById('timetable');
            timetable.innerHTML = '';

            // Check if events exist
            if (!events || events.length === 0) {
                timetable.innerHTML = '<p style="text-align:center;color:#6b7280;padding:1rem;">No upcoming events found.</p>';
                return;
            }

            // Sort events by start time
            const sortedEvents = [...events].sort((a, b) =>
                new Date(a.start_time) - new Date(b.start_time)
            );

            // Create a complete route on the map
            createCompleteRoute(sortedEvents);

            // Render each event
            sortedEvents.forEach((event, index) => {
                const eventElement = document.createElement('div');
                eventElement.className = 'event';
                eventElement.classList.add(event.event_type === 'exam' ? 'event-exam' : 'event-class');

                if (event.is_urgent) {
                    eventElement.classList.add('event-urgent');
                }

                const eventTypeClass = event.event_type === 'exam' ? 'event-type-exam' : 'event-type-class';
                const eventTypeLabel = event.event_type === 'exam' ? 'EXAM' : 'CLASS';

                const courseCode = event.course?.code || 'N/A';
                const roomInfo = event.room ?
                    `${event.room.building || ''} ${event.room.number || ''}`.trim() :
                    'TBA';

                // Add sequence number to event
                eventElement.innerHTML = `
                    <div class="event-header">
                        <div class="event-title-container">
                            <div class="event-title-row">
                                <div class="event-title">${index + 1}. ${event.title || 'Untitled Event'}</div>
                                <div class="event-type ${eventTypeClass}">${eventTypeLabel}</div>
                            </div>
                            <div class="event-course">${courseCode} - ${roomInfo}</div>
                            <div class="event-time">
                                ${formatDate(event.start_time)} â€¢
                                ${formatTime(event.start_time)} - ${formatTime(event.end_time)}
                            </div>
                        </div>
                        <div class="event-right">
                            <div class="event-lecturer">${event.lecturer || 'No lecturer'}</div>
                            ${event.is_urgent ? '<div class="event-urgent-badge">Urgent</div>' : ''}
                        </div>
                    </div>
                `;

                eventElement.addEventListener('click', () => showEventDetails(event));
                timetable.appendChild(eventElement);
            });

            // Add print button
            const printButton = document.createElement('button');
            printButton.className = 'button button-secondary';
            printButton.textContent = 'ðŸ–¨ï¸ Print Timetable';
            printButton.addEventListener('click', () => {
                window.print();
            });
            timetable.appendChild(printButton);

            // Add refresh button
            if (isConnectedMode) {
                const refreshButton = document.createElement('button');
                refreshButton.className = 'button button-primary';
                refreshButton.textContent = 'ðŸ”„ Refresh Data';
                refreshButton.addEventListener('click', fetchEvents);
                refreshButton.style.marginTop = '0.5rem';
                timetable.appendChild(refreshButton);
            }
        }

        // Initialize when the page loads
        document.addEventListener('DOMContentLoaded', function () {
            console.log("Connected page loaded");

            // Check for stored token
            const storedToken = localStorage.getItem('unimate_token');
            const storedUsername = localStorage.getItem('unimate_username');

            if (storedToken && storedUsername) {
                // Auto-login with stored token
                authToken = storedToken;
                currentUsername = storedUsername;
                isConnectedMode = true;
                showDashboard();
                fetchEvents();
            }
        });

        // Clear current route
        function clearRoute() {
            if (currentRoute) {
                if (currentRoute.isGroup) {
                    currentRoute.traverse(child => {
                        if (child.geometry) child.geometry.dispose();
                        if (child.material) child.material.dispose();
                    });
                } else {
                    if (currentRoute.geometry) currentRoute.geometry.dispose();
                    if (currentRoute.material) currentRoute.material.dispose();
                }
                mapScene.remove(currentRoute);
                currentRoute = null;
            }
        }
    </script>
</body>

</html>