<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Unimate - Dashboard</title>
    <link href="../static/site.css" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
    <style>
        .dashboard-container {
            display: flex;
            padding: 1rem;
            gap: 1rem;
            flex: 1;
            overflow: auto;
        }

        .dashboard-panel {
            background-color: #222;
            border-radius: 8px;
            padding: 1rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .panel-title {
            font-size: 1.2rem;
            margin-top: 0;
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid #333;
        }

        .timetable-panel {
            flex: 1;
        }

        .map-panel {
            flex: 2;
        }

        #timetable {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        .timetable-item {
            background-color: #1a1a1a;
            border-radius: 4px;
            padding: 0.75rem;
            border-left: 4px solid #3b82f6;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .timetable-item:hover {
            background-color: #252525;
        }

        .timetable-item.exam {
            border-left-color: #f97316;
        }

        .timetable-item.urgent {
            border: 1px solid #ef4444;
            background-color: rgba(239, 68, 68, 0.1);
        }

        /* Selected timetable item styling for class navigation */
        .timetable-item.selected {
            background-color: #1f3a93 !important;
            border-left-color: #60a5fa !important;
            color: white !important;
        }

        .timetable-item.selected .timetable-title {
            color: white;
        }

        .timetable-item.selected .timetable-info {
            color: #e5e7eb;
        }

        /* Task 1.3: Time-based Visual Indicators */
        /* Upcoming class (within 30 minutes) */
        .timetable-item.upcoming {
            background-color: rgba(34, 197, 94, 0.1);
            border-left-color: #22c55e;
            position: relative;
        }

        .timetable-item.upcoming::before {
            content: "Starting Soon";
            position: absolute;
            top: 0.25rem;
            right: 0.5rem;
            font-size: 0.7rem;
            color: #22c55e;
            font-weight: 600;
            text-transform: uppercase;
        }

        /* Current class (in progress) */
        .timetable-item.in-progress {
            background-color: rgba(59, 130, 246, 0.15);
            border-left-color: #3b82f6;
            border-left-width: 6px;
            position: relative;
            animation: pulse 2s ease-in-out infinite;
        }

        @keyframes pulse {
            0% {
                box-shadow: 0 0 0 0 rgba(59, 130, 246, 0.4);
            }

            50% {
                box-shadow: 0 0 0 10px rgba(59, 130, 246, 0);
            }

            100% {
                box-shadow: 0 0 0 0 rgba(59, 130, 246, 0);
            }
        }

        .timetable-item.in-progress::before {
            content: "In Progress";
            position: absolute;
            top: 0.25rem;
            right: 0.5rem;
            font-size: 0.7rem;
            color: #3b82f6;
            font-weight: 600;
            text-transform: uppercase;
        }

        /* Time-sensitive class (starts in next 15 minutes) */
        .timetable-item.time-sensitive {
            background-color: rgba(251, 146, 60, 0.1);
            border-left-color: #fb923c;
            border-left-width: 6px;
            position: relative;
        }

        .timetable-item.time-sensitive::before {
            content: "⚡ Urgent";
            position: absolute;
            top: 0.25rem;
            right: 0.5rem;
            font-size: 0.7rem;
            color: #fb923c;
            font-weight: 600;
            text-transform: uppercase;
        }

        /* Time countdown display */
        .time-until-class {
            font-size: 0.75rem;
            color: #22c55e;
            margin-top: 0.25rem;
            font-weight: 500;
        }

        .timetable-item.time-sensitive .time-until-class {
            color: #fb923c;
            font-weight: 600;
        }

        .timetable-item.in-progress .time-until-class {
            color: #3b82f6;
        }

        .timetable-title {
            font-weight: 500;
            font-size: 1rem;
            margin-bottom: 0.5rem;
        }

        .timetable-info {
            font-size: 0.8rem;
            color: #888;
        }

        #map-container {
            width: 100%;
            height: 500px;
            background-color: #1a1a1a;
            border-radius: 4px;
            position: relative;
        }

        .user-profile {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        #user-name {
            font-weight: 500;
            color: #ccc;
        }

        .loading-indicator {
            color: #888;
            text-align: center;
            padding: 1rem;
        }

        #status-message {
            position: fixed;
            top: 1rem;
            right: 1rem;
            padding: 0.75rem 1rem;
            border-radius: 4px;
            background-color: #065f46;
            color: white;
            z-index: 1000;
            display: none;
        }

        #status-message.error {
            background-color: #7f1d1d;
        }

        #status-message.show {
            display: block;
        }

        /* 3D Map Controls */
        .dashboard-map-controls {
            display: flex;
            gap: 5px;
        }

        .map-control-btn {
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid #333;
            color: white;
            padding: 8px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.2s;
        }

        .map-control-btn:hover {
            background: rgba(0, 0, 0, 0.9);
        }

        /* Building list panel */
        .building-list {
            max-height: 200px;
            overflow-y: auto;
            margin-top: 10px;
        }

        .building-option {
            padding: 8px;
            margin: 2px 0;
            background: #333;
            border: none;
            color: white;
            border-radius: 4px;
            cursor: pointer;
            width: 100%;
            text-align: left;
            transition: background-color 0.2s;
        }

        .building-option:hover {
            background: #444;
        }

        .building-option.selected {
            background: #1f3a93;
        }

        .route-info {
            margin-top: 10px;
            padding: 8px;
            background: #333;
            border-radius: 4px;
            font-size: 0.9rem;
        }

        /* Building Navigation Panel - Collapsible Design */
        .building-navigation-panel {
            margin-top: 20px;
            border: 1px solid #333;
            border-radius: 6px;
            background: #1e1e1e;
            overflow: hidden;
        }

        .building-nav-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 15px;
            background: #2a2a2a;
            cursor: pointer;
            transition: background-color 0.2s;
            border-bottom: 1px solid #333;
        }

        .building-nav-header:hover {
            background: #333;
        }

        .building-nav-title {
            font-weight: 500;
            color: #ccc;
            font-size: 0.95rem;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .building-nav-icon {
            font-size: 1.1rem;
        }

        .building-nav-toggle {
            color: #888;
            font-size: 0.8rem;
            transition: transform 0.2s;
        }

        .building-nav-toggle.collapsed {
            transform: rotate(-90deg);
        }

        .building-nav-subtitle {
            padding: 8px 15px;
            color: #777;
            font-size: 0.8rem;
            font-style: italic;
            background: #1a1a1a;
            border-bottom: 1px solid #2a2a2a;
        }

        .building-nav-content {
            padding: 15px;
            background: #1e1e1e;
            transition: max-height 0.3s ease-out;
            max-height: 500px;
            overflow: hidden;
        }

        .building-nav-content.collapsed {
            max-height: 0;
            padding: 0 15px;
        }

        .selected-destination {
            color: #888;
            margin-bottom: 10px;
            font-size: 0.9rem;
        }

        /* Building Navigation Panel - Collapsible Design */
        .building-navigation-panel {
            margin-top: 20px;
            border: 1px solid #333;
            border-radius: 6px;
            background: #1e1e1e;
            overflow: hidden;
        }

        .building-nav-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 15px;
            background: #2a2a2a;
            cursor: pointer;
            transition: background-color 0.2s;
            border-bottom: 1px solid #333;
        }

        .building-nav-header:hover {
            background: #333;
        }

        .building-nav-title {
            font-weight: 500;
            color: #ccc;
            font-size: 0.95rem;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .building-nav-icon {
            font-size: 1.1rem;
        }

        .building-nav-toggle {
            color: #888;
            font-size: 0.8rem;
            transition: transform 0.2s;
        }

        .building-nav-toggle.collapsed {
            transform: rotate(-90deg);
        }

        .building-nav-subtitle {
            padding: 8px 15px;
            color: #777;
            font-size: 0.8rem;
            font-style: italic;
            background: #1a1a1a;
            border-bottom: 1px solid #2a2a2a;
        }

        .building-nav-content {
            padding: 15px;
            background: #1e1e1e;
            transition: max-height 0.3s ease-out;
            max-height: 500px;
            overflow: hidden;
        }

        .building-nav-content.collapsed {
            max-height: 0;
            padding: 0 15px;
        }

        .selected-destination {
            color: #888;
            margin-bottom: 10px;
            font-size: 0.9rem;
        }
    </style>
</head>

<body>
    <header>
        <h1>Unimate</h1>
        <div class="search-container">
            <input type="text" class="search-input" placeholder="Search for places, events or people">
        </div>
        <div class="user-profile">
            <span id="user-name">User</span>
            <button class="login-button" id="logout-button">Log out</button>
        </div>
    </header>

    <div class="main-container">
        <div class="dashboard-container">
            <div class="dashboard-panel timetable-panel">
                <h2 class="panel-title">Your Timetable</h2>
                <div id="timetable">
                    <div class="loading-indicator">Loading your timetable...</div>
                </div>

                <!-- Building navigation panel - Collapsible design -->
                <div class="building-navigation-panel">
                    <div class="building-nav-header" onclick="toggleBuildingPanel()"> <span class="building-nav-title">
                            <span class="building-nav-icon">🏢</span> Quick Building Access </span> <span
                            class="building-nav-toggle" id="building-nav-toggle">▼</span> </div>
                    <div class="building-nav-subtitle">Or select any building manually</div>
                    <div class="building-nav-content" id="building-nav-content">
                        <div id="dashboard-selected-destination" class="selected-destination">Select a building</div>
                        <div id="dashboard-distance-info" class="route-info" style="display: none;"></div>
                        <div id="dashboard-building-list" class="building-list"></div>
                    </div>
                </div>
            </div>
            <div class="dashboard-panel map-panel">
                <h2 class="panel-title">Campus Map</h2>
                <div id="map-container"></div>
            </div>
        </div>
    </div>

    <div id="status-message"></div>

    <script>
        // Global variables for map
        let mapScene, mapCamera, mapRenderer;
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        let cameraRotation = { x: 0, y: 0 };

        // Dashboard map interaction variables
        let dashboardSelectedBuilding = null;
        let dashboardCurrentRoute = null;
        let dashboardInteractiveObjects = [];
        let dashboardRaycaster = new THREE.Raycaster();
        let dashboardMouse = new THREE.Vector2();
        let currentUserPosition = { x: 0, z: 0 }; // Default user position

        // Utility function - Define early to avoid hoisting issues
        function showStatusMessage(message, isError = false) {
            const statusEl = document.getElementById('status-message');
            statusEl.textContent = message;
            statusEl.classList.toggle('error', isError);
            statusEl.classList.add('show');
            setTimeout(() => {
                statusEl.classList.remove('show');
            }, 3000);
        }

        // Authentication check and initialization
        document.addEventListener('DOMContentLoaded', function () {
            const token = localStorage.getItem('access_token');
            const username = localStorage.getItem('username');

            console.log("Dashboard loaded, checking authentication");
            console.log("Token exists:", !!token);
            console.log("Username:", username);

            if (!token) {
                console.log("No authentication token found, redirecting to home");
                window.location.href = '/components/connected.html';
                return;
            }

            // Set the username in the UI
            const userNameElement = document.getElementById('user-name');
            if (userNameElement && username) {
                userNameElement.textContent = username;
            }

            console.log("Authentication successful, initializing dashboard");

            // Initialize both timetable and 3D map
            fetchTimetableData();
            initDashboardMap();

            // Set up logout functionality
            document.getElementById('logout-button').addEventListener('click', function () {
                localStorage.removeItem('access_token');
                localStorage.removeItem('refresh_token');
                localStorage.removeItem('username');
                window.location.href = '/components/connected.html';
            });
        });

        // Timetable Functions
        function fetchTimetableData() {
            const token = localStorage.getItem('access_token');
            const username = localStorage.getItem('username');

            console.log("fetchTimetableData called");
            console.log("Token:", token ? "EXISTS" : "MISSING");
            console.log("Username:", username);

            if (!token || !username) {
                console.log("No authentication token or username, cannot fetch timetable");
                renderTimetable([]);
                return;
            }

            // Make real API call to get user events
            const apiUrl = 'http://localhost:8000';
            console.log("Making API call to:", `${apiUrl}/api/user-events/?username=${username}`);

            axios.get(`${apiUrl}/api/user-events/?username=${username}`)
                .then(response => {
                    console.log("Timetable data fetched successfully:", response.data);
                    console.log("Response status:", response.status);
                    console.log("Response headers:", response.headers);

                    const user = response.data.user;
                    const events = user.events || [];

                    console.log("User data:", user);
                    console.log("Events data:", events);

                    if (events.length > 0) {
                        console.log(`Found ${events.length} events for ${username}`);
                        renderTimetable(events);
                        showStatusMessage(`Loaded ${events.length} events`);
                    } else {
                        console.log("No events found for user");
                        renderTimetable([]);
                        showStatusMessage("No events scheduled", true);
                    }
                })
                .catch(error => {
                    console.error("Error fetching timetable data:", error);
                    console.error("Error details:", error.response?.data);
                    console.error("Error status:", error.response?.status);
                    console.error("Error message:", error.message);

                    showStatusMessage("Failed to load timetable", true);

                    // Show fallback message
                    const timetable = document.getElementById('timetable');
                    timetable.innerHTML = '<div class="loading-indicator">Failed to load timetable. Please try refreshing.</div>';
                });
        }

        function renderTimetable(events) {
            const timetable = document.getElementById('timetable');
            timetable.innerHTML = '';

            if (!events || events.length === 0) {
                const noEventsMessage = '<div class="loading-indicator">No events scheduled.</div>';
                timetable.innerHTML = noEventsMessage;
                return;
            }

            events.forEach(event => {
                const item = createTimetableItem(event);
                timetable.appendChild(item);
            });
        }

        function createTimetableItem(event) {
            const item = document.createElement('div');
            item.className = `timetable-item ${event.event_type === 'exam' ? 'exam' : ''}`;
            if (event.is_urgent) {
                item.classList.add('urgent');
            }

            const startTime = new Date(event.start_time);
            const endTime = new Date(event.end_time);
            const now = new Date();

            // Calculate time differences
            const minutesUntilStart = Math.floor((startTime - now) / (1000 * 60));
            const minutesUntilEnd = Math.floor((endTime - now) / (1000 * 60));

            // Apply time-based CSS classes
            if (minutesUntilStart <= 0 && minutesUntilEnd > 0) {
                // Class is currently in progress
                item.classList.add('in-progress');
            } else if (minutesUntilStart > 0 && minutesUntilStart <= 15) {
                // Class starts in 15 minutes or less
                item.classList.add('time-sensitive');
            } else if (minutesUntilStart > 15 && minutesUntilStart <= 30) {
                // Class starts within 30 minutes
                item.classList.add('upcoming');
            }

            // Calculate time until class message
            let timeUntilMessage = '';
            if (minutesUntilStart > 0) {
                if (minutesUntilStart < 60) {
                    timeUntilMessage = `Starts in ${minutesUntilStart} minute${minutesUntilStart !== 1 ? 's' : ''}`;
                } else {
                    const hours = Math.floor(minutesUntilStart / 60);
                    const minutes = minutesUntilStart % 60;
                    timeUntilMessage = `Starts in ${hours}h ${minutes}m`;
                }
            } else if (minutesUntilEnd > 0) {
                if (minutesUntilEnd < 60) {
                    timeUntilMessage = `Ends in ${minutesUntilEnd} minute${minutesUntilEnd !== 1 ? 's' : ''}`;
                } else {
                    const hours = Math.floor(minutesUntilEnd / 60);
                    const minutes = minutesUntilEnd % 60;
                    timeUntilMessage = `Ends in ${hours}h ${minutes}m`;
                }
            }

            item.innerHTML = `
                    <div class="timetable-title">${event.title}</div>
                    <div class="timetable-info">
                        <div>${event.course ? event.course.code : 'N/A'} - ${event.room ? `${event.room.building} ${event.room.number}` : 'TBA'}</div>
                        <div>${startTime.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })} - ${endTime.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}</div>
                        <div>Lecturer: ${event.lecturer || 'N/A'}</div>
                        ${timeUntilMessage ? `<div class="time-until-class">${timeUntilMessage}</div>` : ''}
                    </div>
            `;

            // Add click handler to show event details
            item.addEventListener('click', function () {
                showEventDetails(event);
            });

            return item;
        }

        function showEventDetails(event) {
            const details = `
Event: ${event.title}
Course: ${event.course ? event.course.code + ' - ' + event.course.name : 'N/A'}
Room: ${event.room ? event.room.building + ' ' + event.room.number : 'TBA'}
Time: ${new Date(event.start_time).toLocaleString()} - ${new Date(event.end_time).toLocaleString()}
Lecturer: ${event.lecturer || 'N/A'}
Type: ${event.event_type}
${event.is_urgent ? 'URGENT EVENT' : ''}
            `;
            alert(details);
        }

        // 3D Map Functions - Full Featured Version
        function initDashboardMap() {
            const container = document.getElementById('map-container');

            // Create scene with background color
            mapScene = new THREE.Scene();
            mapScene.background = new THREE.Color(0x1a1a1a);

            // Create camera
            mapCamera = new THREE.PerspectiveCamera(60, container.clientWidth / container.clientHeight, 0.1, 1000);
            mapCamera.position.set(0, 12, 15);
            mapCamera.lookAt(0, 0, 0);

            // Create renderer
            mapRenderer = new THREE.WebGLRenderer({ antialias: true });
            mapRenderer.setSize(container.clientWidth, container.clientHeight);
            mapRenderer.setPixelRatio(window.devicePixelRatio);
            mapRenderer.shadowMap.enabled = true;
            mapRenderer.shadowMap.type = THREE.PCFSoftShadowMap;
            container.appendChild(mapRenderer.domElement);

            // Add lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            mapScene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 20, 10);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 50;
            directionalLight.shadow.camera.left = -25;
            directionalLight.shadow.camera.right = 25;
            directionalLight.shadow.camera.top = 25;
            directionalLight.shadow.camera.bottom = -25;
            mapScene.add(directionalLight);

            // Initialize dashboard interactive objects array
            dashboardInteractiveObjects = [];

            // Create campus model with detailed features
            createDashboardCampusModel();

            // Add event listeners for map interaction
            container.addEventListener('mousedown', onDashboardMapMouseDown);
            document.addEventListener('mousemove', onDashboardMapMouseMove);
            document.addEventListener('mouseup', onDashboardMapMouseUp);
            window.addEventListener('resize', onWindowResize);

            // Create Map Controls UI
            createDashboardMapControls(container);

            // Populate dashboard building list
            populateDashboardBuildingList();

            // Start animation loop
            animateMap();

            // Show success message
            showStatusMessage('Advanced 3D map loaded successfully');
        }

        function createDashboardCampusModel() {
            // Floor/ground - realistic campus grass
            const floorGeometry = new THREE.PlaneGeometry(40, 40);
            const floorMaterial = new THREE.MeshLambertMaterial({
                color: 0x95c795
            });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.position.y = -0.1;
            floor.receiveShadow = true;
            mapScene.add(floor);

            // Campus buildings with detailed architecture
            const buildings = [
                { id: 'main', name: 'Main Building', x: 0, z: 0, width: 4, depth: 3, height: 2, color: 0x555555, type: 'main' },
                { id: 'library', name: 'Library', x: -8, z: 0, width: 3, depth: 3, height: 1.8, color: 0x5A6377, type: 'library' },
                { id: 'science', name: 'Science Block', x: 6, z: -5, width: 3, depth: 2.5, height: 1.5, color: 0x4C6A73, type: 'science' },
                { id: 'engineering', name: 'Engineering Building', x: -5, z: 6, width: 4, depth: 2, height: 2, color: 0x5D6854, type: 'engineering' },
                { id: 'bizschool', name: 'Business School', x: 8, z: 6, width: 5, depth: 3, height: 3, color: 0x876E58, type: 'business' },
                { id: 'student_center', name: 'Student Center', x: 0, z: -8, width: 6, depth: 4, height: 1, color: 0x786558, type: 'student' },
                { id: 'general', name: 'General Building', x: -6, z: -6, width: 3, depth: 5, height: 2, color: 0x606060, type: 'general' },
                { id: 'arts', name: 'Arts Building', x: 10, z: 0, width: 3, depth: 2, height: 2.2, color: 0x67685D, type: 'arts' },
                { id: 'health', name: 'Health Sciences', x: 7, z: -9, width: 2.5, depth: 2.5, height: 2, color: 0x607673, type: 'health' }
            ];

            // Store building references for interaction
            window.dashboardBuildings = {};

            // Create all buildings with detailed features
            buildings.forEach(building => {
                const buildingMesh = createDashboardBuilding(
                    building.x, building.z, building.width, building.depth,
                    building.height, building.color, building.name, building.id, building.type
                );

                // Store reference for interaction
                window.dashboardBuildings[building.id] = {
                    mesh: buildingMesh,
                    data: building
                };
            });

            // Create detailed road network
            createDashboardRoads();

            // Add decorative elements
            addCampusDecorations();
        }

        function createDashboardBuilding(x, z, width, depth, height, color, name, id, type) {
            // Create a group to hold the building and its details
            const buildingGroup = new THREE.Group();
            buildingGroup.position.set(x, 0, z);

            // Create the main building structure
            const geometry = new THREE.BoxGeometry(width, height, depth);
            const material = new THREE.MeshLambertMaterial({
                color: color,
                transparent: false
            });

            const building = new THREE.Mesh(geometry, material);
            building.position.y = height / 2;
            building.castShadow = true;
            building.receiveShadow = true;

            // Store original color for hover effects
            building.userData = {
                originalColor: color,
                name: name,
                id: id,
                type: type
            };

            // Add the main building to the group
            buildingGroup.add(building);

            // Add architectural details based on building type
            addBuildingDetails(buildingGroup, type, width, depth, height, id);

            // Add windows for realism
            addDashboardWindows(buildingGroup, width, depth, height);

            // Add the building group to the scene
            mapScene.add(buildingGroup);

            // Add text label above building
            createBuildingLabel(x, height + 1.2, z, name);

            // Make building interactive
            building.callback = function () {
                selectDashboardDestination(id, name);
            };

            // Add to dashboard interactive objects array
            dashboardInteractiveObjects.push(building);

            return building;
        }

        function addBuildingDetails(buildingGroup, buildingType, width, depth, height, id) {
            const x = 0; // local position in the group
            const z = 0;

            switch (buildingType) {
                case 'library':
                    // Add distinctive roof for library
                    const roofGeometry = new THREE.ConeGeometry(Math.max(width, depth) * 0.7, height * 0.4, 4);
                    const roofMaterial = new THREE.MeshLambertMaterial({ color: 0x333333 });
                    const roof = new THREE.Mesh(roofGeometry, roofMaterial);
                    roof.position.set(x, height + height * 0.2, z);
                    roof.castShadow = true;
                    buildingGroup.add(roof);

                    // Add book symbol
                    const bookGeometry = new THREE.BoxGeometry(width * 0.7, height * 0.2, depth * 0.3);
                    const bookMaterial = new THREE.MeshLambertMaterial({ color: 0x4a5b70 });
                    const book = new THREE.Mesh(bookGeometry, bookMaterial);
                    book.position.set(x, height * 0.8, z);
                    buildingGroup.add(book);
                    break;

                case 'science':
                    // Add dome for science building
                    const domeGeometry = new THREE.SphereGeometry(width * 0.3, 16, 16, 0, Math.PI * 2, 0, Math.PI * 0.5);
                    const domeMaterial = new THREE.MeshLambertMaterial({ color: 0x809AAB, transparent: true, opacity: 0.8 });
                    const dome = new THREE.Mesh(domeGeometry, domeMaterial);
                    dome.position.set(x, height + width * 0.3, z);
                    buildingGroup.add(dome);
                    break;

                case 'engineering':
                    // Add antenna/tower for engineering
                    const towerGeometry = new THREE.CylinderGeometry(0.15, 0.15, height * 0.7, 8);
                    const towerMaterial = new THREE.MeshLambertMaterial({ color: 0xA0A0A0 });
                    const tower = new THREE.Mesh(towerGeometry, towerMaterial);
                    tower.position.set(x, height + height * 0.35, z);
                    tower.castShadow = true;
                    buildingGroup.add(tower);
                    break;

                case 'business':
                    // Add glass panels for modern business look
                    const glassGeometry = new THREE.BoxGeometry(width, height * 0.1, depth);
                    const glassMaterial = new THREE.MeshLambertMaterial({
                        color: 0x87CEEB,
                        transparent: true,
                        opacity: 0.3
                    });
                    for (let i = 1; i <= 3; i++) {
                        const glass = new THREE.Mesh(glassGeometry, glassMaterial);
                        glass.position.set(x, height * 0.2 * i, z);
                        buildingGroup.add(glass);
                    }
                    break;

                case 'student':
                    // Add central area for student center
                    const centerGeometry = new THREE.CylinderGeometry(width * 0.3, width * 0.3, height * 0.3, 16);
                    const centerMaterial = new THREE.MeshLambertMaterial({ color: 0xCDAA88 });
                    const center = new THREE.Mesh(centerGeometry, centerMaterial);
                    center.position.set(x, height + height * 0.15, z);
                    center.castShadow = true;
                    buildingGroup.add(center);
                    break;

                case 'arts':
                    // Add columns for arts building
                    const pillarGeometry = new THREE.CylinderGeometry(0.2, 0.2, height * 0.8, 8);
                    const pillarMaterial = new THREE.MeshLambertMaterial({ color: 0xCCCCCC });

                    for (let i = -1; i <= 1; i += 2) {
                        const pillar = new THREE.Mesh(pillarGeometry, pillarMaterial);
                        pillar.position.set(x + i * width * 0.3, height * 0.4, z + depth * 0.4);
                        pillar.castShadow = true;
                        buildingGroup.add(pillar);
                    }
                    break;
            }
        }

        function addDashboardWindows(buildingGroup, width, depth, height) {
            // Window material with realistic glass look
            const windowMaterial = new THREE.MeshLambertMaterial({
                color: 0x90BBDB,
                transparent: true,
                opacity: 0.7
            });

            // Window dimensions
            const windowWidth = 0.3;
            const windowHeight = 0.4;
            const windowDepth = 0.05;

            // Add windows on front and back faces
            for (let side = 0; side < 2; side++) {
                const frontWindowZ = (side === 0 ? depth / 2 : -depth / 2) + (side === 0 ? 0.01 : -0.01);

                for (let i = -1; i <= 1; i += 2) {
                    const x = i * (width / 3);

                    // Front/back windows
                    const frontWindowGeometry = new THREE.BoxGeometry(windowWidth, windowHeight, windowDepth);
                    const frontWindow = new THREE.Mesh(frontWindowGeometry, windowMaterial);
                    frontWindow.position.set(x, height * 0.4, frontWindowZ);
                    buildingGroup.add(frontWindow);

                    // Add window frames
                    const frameGeometry = new THREE.BoxGeometry(windowWidth + 0.05, windowHeight + 0.05, windowDepth);
                    const frameMaterial = new THREE.MeshLambertMaterial({ color: 0x444444 });
                    const frame = new THREE.Mesh(frameGeometry, frameMaterial);
                    frame.position.set(x, height * 0.4, frontWindowZ);
                    buildingGroup.add(frame);
                }
            }

            // Add side windows
            for (let side = 0; side < 2; side++) {
                const sideWindowX = (side === 0 ? width / 2 : -width / 2) + (side === 0 ? 0.01 : -0.01);

                for (let i = -1; i <= 1; i += 2) {
                    const z = i * (depth / 3);

                    const rightWindowGeometry = new THREE.BoxGeometry(windowDepth, windowHeight, windowWidth);
                    const rightWindow = new THREE.Mesh(rightWindowGeometry, windowMaterial);
                    rightWindow.position.set(sideWindowX, height * 0.4, z);
                    buildingGroup.add(rightWindow);
                }
            }
        }

        function createBuildingLabel(x, y, z, text) {
            // Create canvas for text texture
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 256;
            canvas.height = 64;

            // Draw text
            context.fillStyle = '#ffffff';
            context.font = '24px Arial';
            context.textAlign = 'center';
            context.fillText(text, canvas.width / 2, canvas.height / 2);

            // Create texture and sprite
            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.SpriteMaterial({
                map: texture,
                transparent: true
            });

            const sprite = new THREE.Sprite(material);
            sprite.position.set(x, y, z);
            sprite.scale.set(4, 1, 1);
            mapScene.add(sprite);

            return sprite;
        }

        function createDashboardRoads() {
            const roadMaterial = new THREE.MeshLambertMaterial({
                color: 0x444444,
                transparent: false
            });

            // Main horizontal road
            createDashboardRoad(-15, 0, 30, 2, roadMaterial);

            // Main vertical road
            createDashboardRoad(0, -15, 2, 30, roadMaterial);

            // Secondary roads connecting buildings
            createDashboardRoad(-10, 5, 10, 1.5, roadMaterial);
            createDashboardRoad(5, 5, 10, 1.5, roadMaterial);
            createDashboardRoad(-10, -7, 15, 1.5, roadMaterial);
            createDashboardRoad(7, -7, 8, 1.5, roadMaterial);

            // Parking areas
            createDashboardRoad(-12, 10, 4, 3, new THREE.MeshLambertMaterial({ color: 0x333333 }));
            createDashboardRoad(12, -12, 4, 3, new THREE.MeshLambertMaterial({ color: 0x333333 }));
        }

        function createDashboardRoad(x, z, width, depth, material) {
            const roadGeo = new THREE.PlaneGeometry(width, depth);
            const road = new THREE.Mesh(roadGeo, material);
            road.rotation.x = -Math.PI / 2;
            road.position.y = -0.05;
            road.position.x = x;
            road.position.z = z;
            road.receiveShadow = true;
            mapScene.add(road);
            return road;
        }

        function addCampusDecorations() {
            // Add trees
            for (let i = 0; i < 20; i++) {
                const treeX = (Math.random() - 0.5) * 35;
                const treeZ = (Math.random() - 0.5) * 35;

                // Don't place trees too close to buildings or roads
                let tooClose = false;
                Object.values(window.dashboardBuildings || {}).forEach(building => {
                    const dist = Math.sqrt((treeX - building.data.x) ** 2 + (treeZ - building.data.z) ** 2);
                    if (dist < 3) tooClose = true;
                });

                if (!tooClose) {
                    createTree(treeX, treeZ);
                }
            }

            // Add benches along paths
            createBench(-5, -2);
            createBench(5, 2);
            createBench(-2, 5);
            createBench(2, -5);
        }

        function createTree(x, z) {
            const treeGroup = new THREE.Group();

            // Trunk
            const trunkGeometry = new THREE.CylinderGeometry(0.1, 0.15, 1, 8);
            const trunkMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.position.y = 0.5;
            trunk.castShadow = true;
            treeGroup.add(trunk);

            // Leaves
            const leavesGeometry = new THREE.SphereGeometry(0.8, 8, 6);
            const leavesMaterial = new THREE.MeshLambertMaterial({ color: 0x228B22 });
            const leaves = new THREE.Mesh(leavesGeometry, leavesMaterial);
            leaves.position.y = 1.3;
            leaves.castShadow = true;
            treeGroup.add(leaves);

            treeGroup.position.set(x, 0, z);
            mapScene.add(treeGroup);
        }

        function createBench(x, z) {
            const benchGroup = new THREE.Group();

            // Bench seat
            const seatGeometry = new THREE.BoxGeometry(1.5, 0.1, 0.4);
            const benchMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
            const seat = new THREE.Mesh(seatGeometry, benchMaterial);
            seat.position.y = 0.3;
            seat.castShadow = true;
            benchGroup.add(seat);

            // Bench legs
            const legGeometry = new THREE.BoxGeometry(0.1, 0.3, 0.1);
            for (let i = 0; i < 4; i++) {
                const leg = new THREE.Mesh(legGeometry, benchMaterial);
                leg.position.set(
                    (i % 2 === 0 ? -0.6 : 0.6),
                    0.15,
                    (i < 2 ? -0.15 : 0.15)
                );
                leg.castShadow = true;
                benchGroup.add(leg);
            }

            benchGroup.position.set(x, 0, z);
            mapScene.add(benchGroup);
        }

        function onDashboardMapMouseDown(event) {
            // Handle drag start for camera rotation
            isDragging = true;
            previousMousePosition = {
                x: event.clientX,
                y: event.clientY
            };

            // Handle object selection on click
            event.preventDefault();

            // Get normalized device coordinates
            const container = document.getElementById('map-container');
            const rect = container.getBoundingClientRect();
            dashboardMouse.x = ((event.clientX - rect.left) / container.clientWidth) * 2 - 1;
            dashboardMouse.y = -((event.clientY - rect.top) / container.clientHeight) * 2 + 1;

            // Update the raycaster
            dashboardRaycaster.setFromCamera(dashboardMouse, mapCamera);

            // Check for intersections with interactive objects
            const intersects = dashboardRaycaster.intersectObjects(dashboardInteractiveObjects);

            if (intersects.length > 0) {
                // Call the callback function of the intersected object
                if (intersects[0].object.callback) {
                    intersects[0].object.callback();
                }
            }
        }

        function onDashboardMapMouseMove(event) {
            // Handle hover effect for interactive objects when not dragging
            if (!isDragging) {
                // Handle hover effect for interactive objects
                const container = document.getElementById('map-container');
                const rect = container.getBoundingClientRect();
                dashboardMouse.x = ((event.clientX - rect.left) / container.clientWidth) * 2 - 1;
                dashboardMouse.y = -((event.clientY - rect.top) / container.clientHeight) * 2 + 1;

                // Update the raycaster
                dashboardRaycaster.setFromCamera(dashboardMouse, mapCamera);

                // Check for intersections with interactive objects
                const intersects = dashboardRaycaster.intersectObjects(dashboardInteractiveObjects);

                // Reset all buildings to original color (except selected)
                dashboardInteractiveObjects.forEach(obj => {
                    if (dashboardSelectedBuilding && obj.userData.id === dashboardSelectedBuilding) return;
                    obj.material.emissive.setHex(0x000000);
                });

                // Show cursor pointer and highlight hovered building
                if (intersects.length > 0) {
                    document.body.style.cursor = 'pointer';

                    // Don't highlight if it's the selected building
                    if (!dashboardSelectedBuilding || intersects[0].object.userData.id !== dashboardSelectedBuilding) {
                        intersects[0].object.material.emissive.setHex(0x333333);
                    }
                } else {
                    document.body.style.cursor = 'default';
                }
                return;
            }

            // Handle camera rotation when dragging
            const deltaMove = {
                x: event.clientX - previousMousePosition.x,
                y: event.clientY - previousMousePosition.y
            };

            // Rotate camera based on mouse movement
            cameraRotation.y += deltaMove.x * 0.01;
            cameraRotation.x += deltaMove.y * 0.01;

            // Limit vertical rotation
            cameraRotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, cameraRotation.x));

            // Calculate camera position
            const distance = mapCamera.position.length();
            mapCamera.position.x = distance * Math.sin(cameraRotation.y) * Math.cos(cameraRotation.x);
            mapCamera.position.z = distance * Math.cos(cameraRotation.y) * Math.cos(cameraRotation.x);
            mapCamera.position.y = distance * Math.sin(cameraRotation.x);

            mapCamera.lookAt(0, 0, 0);

            previousMousePosition = {
                x: event.clientX,
                y: event.clientY
            };
        }

        function onDashboardMapMouseUp() {
            isDragging = false;
        }

        function onWindowResize() {
            const container = document.getElementById('map-container');
            mapCamera.aspect = container.clientWidth / container.clientHeight;
            mapCamera.updateProjectionMatrix();
            mapRenderer.setSize(container.clientWidth, container.clientHeight);
        }

        function createDashboardMapControls(container) {
            // Create control container
            const controlsDiv = document.createElement('div');
            controlsDiv.className = 'dashboard-map-controls';
            controlsDiv.style.position = 'absolute';
            controlsDiv.style.top = '10px';
            controlsDiv.style.right = '10px';
            controlsDiv.style.zIndex = '10';
            container.appendChild(controlsDiv);

            // Create clear routes button
            const clearRoutesBtn = document.createElement('button');
            clearRoutesBtn.className = 'map-control-btn';
            clearRoutesBtn.innerHTML = '✕';
            clearRoutesBtn.title = 'Clear Routes';
            clearRoutesBtn.addEventListener('click', function () {
                clearDashboardRoute();
            });
            controlsDiv.appendChild(clearRoutesBtn);

            // Create reset view button
            const resetViewBtn = document.createElement('button');
            resetViewBtn.className = 'map-control-btn';
            resetViewBtn.innerHTML = '⌂';
            resetViewBtn.title = 'Reset View';
            resetViewBtn.addEventListener('click', function () {
                // Reset camera position
                mapCamera.position.set(0, 12, 15);
                mapCamera.lookAt(0, 0, 0);
                cameraRotation = { x: 0, y: 0 };
                showStatusMessage('View reset');
            });
            controlsDiv.appendChild(resetViewBtn);
        }

        function populateDashboardBuildingList() {
            const buildingList = document.getElementById('dashboard-building-list');
            if (!buildingList) return;

            // Campus buildings data
            const buildings = [
                { id: 'main', name: 'Main Building' },
                { id: 'library', name: 'Library' },
                { id: 'science', name: 'Science Block' },
                { id: 'engineering', name: 'Engineering Building' },
                { id: 'bizschool', name: 'Business School' },
                { id: 'student_center', name: 'Student Center' },
                { id: 'general', name: 'General Building' },
                { id: 'arts', name: 'Arts Building' },
                { id: 'health', name: 'Health Sciences' }
            ];

            buildings.forEach(building => {
                const button = document.createElement('button');
                button.className = 'building-option';
                button.textContent = building.name;
                button.setAttribute('data-building-id', building.id);

                button.addEventListener('click', function () {
                    selectDashboardDestination(building.id, building.name);
                });

                buildingList.appendChild(button);
            });
        }

        function selectDashboardDestination(buildingId, buildingName) {
            // Clear any existing routes first
            clearDashboardRoute();

            // Deselect previous building if any
            if (dashboardSelectedBuilding) {
                const prevBuilding = window.dashboardBuildings[dashboardSelectedBuilding];
                if (prevBuilding && prevBuilding.mesh) {
                    prevBuilding.mesh.material.color.setHex(prevBuilding.mesh.userData.originalColor);
                    prevBuilding.mesh.material.emissive.setHex(0x000000);
                }
            }

            // Select new building
            dashboardSelectedBuilding = buildingId;
            const building = window.dashboardBuildings[buildingId];

            if (building && building.mesh) {
                // Highlight selected building
                building.mesh.material.emissive.setHex(0x1f3a93);

                // Show selection in UI
                showStatusMessage(`Selected destination: ${buildingName}`);

                // Update destination display in UI
                const destinationElement = document.getElementById('dashboard-selected-destination');
                if (destinationElement) {
                    destinationElement.textContent = buildingName;
                    destinationElement.style.color = '#3b82f6';
                }

                // Calculate and show route
                dashboardCurrentRoute = calculateDashboardRoute(currentUserPosition, {
                    x: building.data.x,
                    z: building.data.z
                });

                // Update building list selection
                const buttons = document.querySelectorAll('#dashboard-building-list .building-option');
                buttons.forEach(btn => btn.classList.remove('selected'));

                const selectedButton = document.querySelector(`#dashboard-building-list .building-option[data-building-id="${buildingId}"]`);
                if (selectedButton) {
                    selectedButton.classList.add('selected');
                }
            }
        }

        function calculateDashboardRoute(from, to) {
            // Generate a route color
            const routeColor = 0x00ff00;

            // Create a simple route (in real app this would use pathfinding)
            const points = [
                new THREE.Vector3(from.x, 0.1, from.z),
                new THREE.Vector3((from.x + to.x) / 2, 0.1, from.z),
                new THREE.Vector3((from.x + to.x) / 2, 0.1, to.z),
                new THREE.Vector3(to.x, 0.1, to.z)
            ];

            // Create a smooth path with a curve
            const curve = new THREE.CatmullRomCurve3(points);
            const routePoints = curve.getPoints(50);

            // Create line geometry for the route
            const routeGeometry = new THREE.BufferGeometry().setFromPoints(routePoints);

            // Create animated line material
            const routeMaterial = new THREE.LineBasicMaterial({
                color: routeColor,
                linewidth: 3
            });

            // Create the line and add to scene
            const routeLine = new THREE.Line(routeGeometry, routeMaterial);
            routeLine.userData = {
                color: routeColor,
                markers: [],
                buildingId: dashboardSelectedBuilding
            };
            mapScene.add(routeLine);

            // Add location marker at the start position
            const startMarker = createLocationMarker(from.x, from.z);
            routeLine.userData.markers.push(startMarker);

            // Add destination marker
            const endMarker = createDestinationMarker(to.x, to.z);
            routeLine.userData.markers.push(endMarker);

            // Calculate and show distance
            const distance = calculateDistance(from, to);
            const walkingSpeed = 1.4; // meters per second
            const walkingTimeSeconds = distance / walkingSpeed;
            const walkingTimeMinutes = Math.max(2, Math.min(10, Math.ceil(walkingTimeSeconds / 60)));

            const distanceInfo = document.getElementById('dashboard-distance-info');
            if (distanceInfo) {
                distanceInfo.textContent = `Distance: ${Math.round(distance)} m • Walking time: ${walkingTimeMinutes} min`;
                distanceInfo.style.display = 'block';
                distanceInfo.style.color = '#3b82f6';
            }

            return routeLine;
        }

        function createLocationMarker(x, z) {
            const markerGeometry = new THREE.CylinderGeometry(0.3, 0.3, 0.2, 16);
            const markerMaterial = new THREE.MeshLambertMaterial({ color: 0x00ff00 });
            const marker = new THREE.Mesh(markerGeometry, markerMaterial);
            marker.position.set(x, 0.2, z);
            marker.castShadow = true;
            mapScene.add(marker);
            return marker;
        }

        function createDestinationMarker(x, z) {
            const markerGeometry = new THREE.CylinderGeometry(0.3, 0, 0.5, 16);
            const markerMaterial = new THREE.MeshLambertMaterial({ color: 0xff0000 });
            const marker = new THREE.Mesh(markerGeometry, markerMaterial);
            marker.position.set(x, 0.3, z);
            marker.castShadow = true;
            mapScene.add(marker);
            return marker;
        }

        function clearDashboardRoute() {
            if (dashboardCurrentRoute) {
                // Remove the route line
                mapScene.remove(dashboardCurrentRoute);

                // Remove any associated markers
                if (dashboardCurrentRoute.userData && dashboardCurrentRoute.userData.markers) {
                    dashboardCurrentRoute.userData.markers.forEach(marker => {
                        mapScene.remove(marker);
                    });
                }

                dashboardCurrentRoute = null;
            }

            // Reset selected building
            if (dashboardSelectedBuilding) {
                const prevBuilding = window.dashboardBuildings[dashboardSelectedBuilding];
                if (prevBuilding && prevBuilding.mesh) {
                    prevBuilding.mesh.material.color.setHex(prevBuilding.mesh.userData.originalColor);
                    prevBuilding.mesh.material.emissive.setHex(0x000000);
                }
                dashboardSelectedBuilding = null;
            }

            // Reset destination UI
            const destinationElement = document.getElementById('dashboard-selected-destination');
            if (destinationElement) {
                destinationElement.textContent = 'Select a building';
                destinationElement.style.color = '#888';
            }

            // Reset distance info
            const distanceInfo = document.getElementById('dashboard-distance-info');
            if (distanceInfo) {
                distanceInfo.style.display = 'none';
            }

            // Clear selected state from building buttons
            document.querySelectorAll('#dashboard-building-list .building-option').forEach(btn => {
                btn.classList.remove('selected');
            });

            showStatusMessage('Routes cleared');
        }

        function calculateDistance(from, to) {
            const dx = to.x - from.x;
            const dz = to.z - from.z;
            return Math.sqrt(dx * dx + dz * dz) * 5; // Scale factor for realistic distance
        }

        function animateMap() {
            requestAnimationFrame(animateMap);
            mapRenderer.render(mapScene, mapCamera);
        }

        // Building Navigation Panel Toggle Function
        function toggleBuildingPanel() {
            const content = document.getElementById('building-nav-content');
            const toggle = document.getElementById('building-nav-toggle');

            if (content && toggle) {
                // Toggle collapsed state
                const isCollapsed = content.classList.contains('collapsed');

                if (isCollapsed) {
                    // Expand
                    content.classList.remove('collapsed');
                    toggle.classList.remove('collapsed');
                    toggle.textContent = '▼';
                    showStatusMessage('Building navigation expanded');
                } else {
                    // Collapse
                    content.classList.add('collapsed');
                    toggle.classList.add('collapsed');
                    toggle.textContent = '▶';
                    showStatusMessage('Building navigation collapsed');
                }
            }
        }
    </script>
</body>

</html>