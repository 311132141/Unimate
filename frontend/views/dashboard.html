<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Unimate - Dashboard</title>
    <link href="../static/site.css" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
    <style>
        .dashboard-container {
            display: flex;
            padding: 1rem;
            gap: 1rem;
            flex: 1;
            overflow: auto;
        }

        .dashboard-panel {
            background-color: #222;
            border-radius: 8px;
            padding: 1rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .panel-title {
            font-size: 1.2rem;
            margin-top: 0;
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid #333;
        }

        .timetable-panel {
            flex: 1;
        }

        .map-panel {
            flex: 2;
        }

        #timetable {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        .timetable-item {
            background-color: #1a1a1a;
            border-radius: 4px;
            padding: 0.75rem;
            border-left: 4px solid #3b82f6;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .timetable-item:hover {
            background-color: #252525;
        }

        .timetable-item.exam {
            border-left-color: #f97316;
        }

        .timetable-item.urgent {
            border: 1px solid #ef4444;
            background-color: rgba(239, 68, 68, 0.1);
        }

        .timetable-title {
            font-weight: 500;
            font-size: 1rem;
            margin-bottom: 0.5rem;
        }

        .timetable-info {
            font-size: 0.8rem;
            color: #888;
        }

        #map-container {
            width: 100%;
            height: 500px;
            background-color: #1a1a1a;
            border-radius: 4px;
            position: relative;
        }

        #fullscreen-map-container {
            width: 100%; 
            height: calc(100vh - 60px); 
            position: relative;
            background-color: #1a1a1a;
        }

        .user-profile {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        #user-name {
            font-weight: 500;
            color: #ccc;
        }

        .active {
            background-color: #2a2a2a;
        }

        .loading-indicator {
            color: #888;
            text-align: center;
            padding: 1rem;
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            .dashboard-container {
                flex-direction: column;
            }
        }

        /* Status message styles */
        #status-message {
            position: fixed;
            top: 1rem;
            right: 1rem;
            padding: 0.75rem 1rem;
            border-radius: 4px;
            background-color: #065f46;
            color: white;
            z-index: 1000;
            display: none;
            animation: fadeIn 0.3s, fadeOut 0.3s 2.5s;
            opacity: 0;
        }

        #status-message.error {
            background-color: #7f1d1d;
        }

        #status-message.show {
            display: block;
            opacity: 1;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes fadeOut {
            from { opacity: 1; }
            to { opacity: 0; }
        }

        /* Add styles for the different views */
        .view-container {
            flex: 1;
            display: none; /* Hide all views by default */
        }

        .view-container.active {
            display: flex; /* Show only the active view */
        }

        #dashboard-view {
            flex-direction: row;
            gap: 1rem;
        }

        #timetable-view, #map-view, #events-view, #settings-view {
            flex-direction: column;
        }
        
        /* Map Navigation UI */
        #map-controls, .dashboard-map-controls {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 10;
        }
        
        .map-control-btn {
            width: 40px;
            height: 40px;
            background: rgba(0, 0, 0, 0.7);
            border: none;
            border-radius: 5px;
            color: white;
            font-size: 20px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.2s;
        }
        
        .map-control-btn:hover {
            background: rgba(50, 50, 50, 0.9);
        }
        
        /* Building selection UI */
        #building-selector {
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 5px;
            position: absolute;
            bottom: 20px;
            left: 20px;
            z-index: 10;
            max-width: 250px;
        }
        
        #building-selector h3 {
            color: white;
            margin-top: 0;
            margin-bottom: 10px;
            font-size: 14px;
        }
        
        #building-list {
            display: flex;
            flex-direction: column;
            gap: 5px;
            max-height: 200px;
            overflow-y: auto;
        }
        
        .building-option {
            background: rgba(60, 60, 60, 0.7);
            color: white;
            border: none;
            border-radius: 3px;
            padding: 8px 12px;
            text-align: left;
            cursor: pointer;
            font-size: 12px;
            transition: background-color 0.2s;
            display: flex;
            align-items: center;
        }
        
        .building-option:hover {
            background: rgba(80, 80, 80, 0.9);
        }
        
        .building-option.selected {
            background: #1f3a93;
        }
        
        /* Add checkbox style for building options */
        .building-option:before {
            content: "";
            display: inline-block;
            width: 14px;
            height: 14px;
            margin-right: 8px;
            border: 1px solid #ccc;
            border-radius: 2px;
            background-color: transparent;
        }
        
        .building-option.selected:before {
            background-color: #1f3a93;
            content: "âœ“";
            font-size: 10px;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        /* Dashboard building selector */
        #dashboard-building-selector {
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            position: absolute;
            bottom: 15px;
            left: 15px;
            z-index: 10;
            max-width: 200px;
        }
        
        #dashboard-building-selector h3 {
            color: white;
            margin-top: 0;
            margin-bottom: 8px;
            font-size: 12px;
        }
        
        #dashboard-building-list {
            display: flex;
            flex-direction: column;
            gap: 5px;
            max-height: 150px;
            overflow-y: auto;
        }
        
        /* Dashboard route info */
        #dashboard-route-info {
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            position: absolute;
            top: 15px;
            left: 15px;
            z-index: 10;
            color: white;
            max-width: 200px;
            font-size: 12px;
        }
        
        #dashboard-route-info h3 {
            margin-top: 0;
            margin-bottom: 5px;
            font-size: 12px;
        }
        
        #dashboard-selected-destination {
            font-weight: bold;
            color: #4dabf7;
        }
        
        /* Match mockup header */
        header {
            background-color: #1a1a1a;
            border-bottom: 1px solid #333;
            padding: 0.5rem 1rem;
        }
        
        /* View titles */
        .view-title {
            margin-top: 0;
            margin-bottom: 1rem;
            font-size: 1.5rem;
            color: #ffffff;
        }
        
        /* Make the sidebar match the mockup */
        .sidebar {
            background-color: #1a1a1a;
            border-right: 1px solid #333;
            min-width: 180px;
        }
        
        .sidebar-section h2 {
            font-size: 1rem;
            padding: 0.75rem 1rem;
            margin: 0;
            color: #888;
        }
        
        .event-item {
            padding: 0.75rem 1rem;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        
        .event-item:hover {
            background-color: #252525;
        }
        
        .event-item.active {
            background-color: #2a2a2a;
            border-left: 3px solid #3b82f6;
        }
        
        /* Map tooltip */
        #map-tooltip {
            position: fixed;
            background-color: rgba(0,0,0,0.7);
            color: white;
            padding: 5px 10px;
            border-radius: 3px;
            font-size: 12px;
            display: none;
            z-index: 1000;
            border: 1px solid #3b82f6;
        }
    </style>
</head>

<body>
    <header>
        <h1>Unimate</h1>
        <div class="search-container">
            <input type="text" class="search-input" placeholder="Search for places, events or people">
        </div>
        <div class="user-profile">
            <span id="user-name">User</span>
            <button class="login-button" id="logout-button">Log out</button>
        </div>
    </header>

    <div class="main-container">
        <div class="sidebar">
            <div class="sidebar-section">
                <h2>Navigation</h2>
                <div class="event-list">
                    <div class="event-item active" data-view="dashboard-view">
                        <div class="event-content">
                            <div class="event-title">Dashboard</div>
                        </div>
                    </div>
                    <div class="event-item" data-view="timetable-view">
                        <div class="event-content">
                            <div class="event-title">Timetable</div>
                        </div>
                    </div>
                    <div class="event-item" data-view="map-view">
                        <div class="event-content">
                            <div class="event-title">Map</div>
                        </div>
                    </div>
                    <div class="event-item" data-view="events-view">
                        <div class="event-content">
                            <div class="event-title">Events</div>
                        </div>
                    </div>
                    <div class="event-item" data-view="settings-view">
                        <div class="event-content">
                            <div class="event-title">Settings</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Different view containers -->
        <div id="dashboard-view" class="view-container active">
            <div class="dashboard-panel timetable-panel">
                <h2 class="panel-title">Your Timetable</h2>
                <div id="timetable">
                    <!-- Timetable will be rendered here by app.js -->
                    <div class="loading-indicator">Loading your timetable...</div>
                </div>
            </div>
            <div class="dashboard-panel map-panel">
                <h2 class="panel-title">Campus Map</h2>
                <div id="map-container">
                    <!-- 3D Map will be rendered here -->
                    
                    <!-- Route information for dashboard map -->
                    <div id="dashboard-route-info">
                        <h3>Navigation</h3>
                        <div>From: <span id="dashboard-current-location">Main Entrance</span></div>
                        <div>To: <span id="dashboard-selected-destination">Select a building</span></div>
                        <div id="dashboard-distance-info" style="margin-top: 5px; font-size: 11px;"></div>
                    </div>
                    
                    <!-- Building selector for dashboard map -->
                    <div id="dashboard-building-selector">
                        <h3>Campus Buildings</h3>
                        <div id="dashboard-building-list"></div>
                    </div>
                </div>
            </div>
        </div>

        <div id="timetable-view" class="view-container">
            <h2 class="view-title">Full Timetable</h2>
                <div id="full-timetable">
                    <div class="loading-indicator">Loading your complete timetable...</div>
                    <!-- Will be populated with the same data as the dashboard timetable -->
            </div>
        </div>

        <div id="map-view" class="view-container">
            <h2 class="view-title">Campus Map</h2>
            <div id="fullscreen-map-container">
                <!-- Map controls -->
                <div id="map-controls">
                    <button class="map-control-btn" id="zoom-in-btn" title="Zoom In">+</button>
                    <button class="map-control-btn" id="zoom-out-btn" title="Zoom Out">-</button>
                    <button class="map-control-btn" id="reset-view-btn" title="Reset View">âŸ²</button>
                    <button class="map-control-btn" id="top-view-btn" title="Top View">â¤“</button>
                </div>
                
                <!-- Route information -->
                <div id="route-info">
                    <h3>Navigation</h3>
                    <div>From: <span id="current-location">Main Entrance</span></div>
                    <div>To: <span id="selected-destination">Select a building</span></div>
                    <div id="distance-info" style="margin-top: 5px; font-size: 12px;"></div>
                </div>
                
                <!-- Building selector -->
                <div id="building-selector">
                    <h3>Campus Buildings</h3>
                    <div id="building-list"></div>
                </div>
            </div>
        </div>

        <div id="events-view" class="view-container">
            <h2 class="view-title">Campus Events</h2>
                <div id="events-list">
                    <div class="event-item">
                        <div class="event-content">
                            <div class="event-title">Tech Week Exhibition</div>
                            <div class="event-meta">Tomorrow at 10:00 AM Â· Engineering Building</div>
                            <div class="event-meta">Join us for demonstrations of student projects</div>
                        </div>
                    </div>
                    <div class="event-item">
                        <div class="event-content">
                            <div class="event-title">Guest Lecture: AI Ethics</div>
                            <div class="event-meta">May 20 at 2:00 PM Â· Lecture Hall 4</div>
                            <div class="event-meta">Prof. Maria Johnson from Stanford University</div>
                        </div>
                    </div>
                    <div class="event-item">
                        <div class="event-content">
                            <div class="event-title">Career Fair 2025</div>
                            <div class="event-meta">June 5 at 9:00 AM Â· Student Center</div>
                            <div class="event-meta">Over 50 companies will be present</div>
                    </div>
                </div>
            </div>
        </div>

        <div id="settings-view" class="view-container">
            <h2 class="view-title">Settings</h2>
                <div style="padding:1rem;">
                    <div style="margin-bottom:1.5rem;">
                        <h3 style="margin-top:0;">User Settings</h3>
                        <div style="margin-bottom:1rem;">
                            <label style="display:block; margin-bottom:0.5rem;">Display Name</label>
                            <input type="text" class="search-input" style="max-width:300px;" value="John Doe">
                        </div>
                        <div style="margin-bottom:1rem;">
                            <label style="display:block; margin-bottom:0.5rem;">Email Notifications</label>
                            <label style="display:flex; align-items:center; gap:0.5rem;">
                                <input type="checkbox" checked> Receive notifications about timetable changes
                            </label>
                        </div>
                    </div>
                    <div>
                        <h3>Application Settings</h3>
                        <div style="margin-bottom:1rem;">
                            <label style="display:block; margin-bottom:0.5rem;">Theme</label>
                            <select class="search-input" style="max-width:300px;">
                                <option selected>Dark Theme</option>
                                <option>Light Theme</option>
                                <option>System Default</option>
                            </select>
                        </div>
                        <div>
                            <button class="login-button">Save Changes</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="status-message"></div>

    <script>
        // Global variables for map
        let mapScene, mapCamera, mapRenderer;
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        let cameraRotation = { x: 0, y: 0 };
        
        // Variables for fullscreen map
        let fullscreenMapScene, fullscreenMapCamera, fullscreenMapRenderer;
        let fullscreenCameraRotation = { x: 0, y: 0 };
        
        // Dashboard map interaction variables
        let dashboardSelectedBuilding = null;
        let dashboardCurrentRoute = null;
        let dashboardInteractiveObjects = [];
        let dashboardRaycaster = new THREE.Raycaster();
        let dashboardMouse = new THREE.Vector2();
        let dashboardIsFullscreenDragging = false;
        
        document.addEventListener('DOMContentLoaded', function() {
            // Check if user is logged in
            const token = localStorage.getItem('access_token');
            const username = localStorage.getItem('username');
            
            if (token) {
                // Update UI for logged-in user
                if (username) {
                    document.getElementById('user-name').textContent = username;
                }
                
                // Initialize 3D map
                initDashboardMap();
                
                // Fetch and load timetable data
                fetchTimetableData();
                
                // Setup navigation
                setupNavigation();
            } else {
                // Redirect to login page if not authenticated
                window.location.href = 'index.html';
            }
            
            // Set up logout functionality
            document.getElementById('logout-button').addEventListener('click', function() {
                localStorage.removeItem('access_token');
                localStorage.removeItem('refresh_token');
                localStorage.removeItem('username');
                
                // Redirect to login page
                window.location.href = 'index.html';
            });
        });
        
        function initDashboardMap() {
            const container = document.getElementById('map-container');
            
            // Create scene with background color
            mapScene = new THREE.Scene();
            mapScene.background = new THREE.Color(0x1a1a1a);
            
            // Create camera
            mapCamera = new THREE.PerspectiveCamera(60, container.clientWidth / container.clientHeight, 0.1, 1000);
            mapCamera.position.set(0, 12, 15);
            mapCamera.lookAt(0, 0, 0);
            
            // Create renderer
            mapRenderer = new THREE.WebGLRenderer({ antialias: true });
            mapRenderer.setSize(container.clientWidth, container.clientHeight);
            mapRenderer.setPixelRatio(window.devicePixelRatio);
            mapRenderer.shadowMap.enabled = true;
            container.appendChild(mapRenderer.domElement);
            
            // Add lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            mapScene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 10, 5);
            directionalLight.castShadow = true;
            mapScene.add(directionalLight);
            
            // Initialize dashboard interactive objects array
            dashboardInteractiveObjects = [];
            
            // Create campus model with same structure as fullscreen map
            createDashboardCampusModel();
            
            // Add event listeners for map interaction
            container.addEventListener('mousedown', onDashboardMapMouseDown);
            document.addEventListener('mousemove', onDashboardMapMouseMove);
            document.addEventListener('mouseup', onDashboardMapMouseUp);
            window.addEventListener('resize', onWindowResize);
            
            // Create Map Controls UI
            createDashboardMapControls(container);
            
            // Populate dashboard building list
            populateDashboardBuildingList();
            
            // Start animation loop
            animateMap();
            
            // Show success message
            showStatusMessage('3D map loaded successfully');
        }
        
        function onDashboardMapMouseDown(event) {
            // Handle drag start for camera rotation
            isDragging = true;
            previousMousePosition = {
                x: event.clientX,
                y: event.clientY
            };
            
            // Handle object selection on click
            event.preventDefault();
            
            // Get normalized device coordinates
            const container = document.getElementById('map-container');
            const rect = container.getBoundingClientRect();
            dashboardMouse.x = ((event.clientX - rect.left) / container.clientWidth) * 2 - 1;
            dashboardMouse.y = -((event.clientY - rect.top) / container.clientHeight) * 2 + 1;
            
            // Update the raycaster
            dashboardRaycaster.setFromCamera(dashboardMouse, mapCamera);
            
            // Check for intersections with interactive objects
            const intersects = dashboardRaycaster.intersectObjects(dashboardInteractiveObjects);
            
            if (intersects.length > 0) {
                // Call the callback function of the intersected object
                if (intersects[0].object.callback) {
                    intersects[0].object.callback();
                }
            }
        }
        
        function onDashboardMapMouseMove(event) {
            // Handle hover effect for interactive objects when not dragging
            if (!isDragging) {
                // Handle hover effect for interactive objects
                const container = document.getElementById('map-container');
                const rect = container.getBoundingClientRect();
                dashboardMouse.x = ((event.clientX - rect.left) / container.clientWidth) * 2 - 1;
                dashboardMouse.y = -((event.clientY - rect.top) / container.clientHeight) * 2 + 1;
                
                // Update the raycaster
                dashboardRaycaster.setFromCamera(dashboardMouse, mapCamera);
                
                // Check for intersections with interactive objects
                const intersects = dashboardRaycaster.intersectObjects(dashboardInteractiveObjects);
                
                // Reset all buildings to original color (except selected)
                dashboardInteractiveObjects.forEach(obj => {
                    if (dashboardSelectedBuilding && obj.userData.id === dashboardSelectedBuilding) return;
                    obj.material.emissive.setHex(0x000000);
                });
                
                // Show cursor pointer and highlight hovered building
                if (intersects.length > 0) {
                    document.body.style.cursor = 'pointer';
                    
                    // Don't highlight if it's the selected building
                    if (!dashboardSelectedBuilding || intersects[0].object.userData.id !== dashboardSelectedBuilding) {
                        intersects[0].object.material.emissive.setHex(0x333333);
                    }
                } else {
                    document.body.style.cursor = 'default';
                }
                return;
            }
            
            // Handle camera rotation when dragging
            const deltaMove = {
                x: event.clientX - previousMousePosition.x,
                y: event.clientY - previousMousePosition.y
            };
            
            // Rotate camera based on mouse movement
            cameraRotation.y += deltaMove.x * 0.01;
            cameraRotation.x += deltaMove.y * 0.01;
            
            // Limit vertical rotation
            cameraRotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, cameraRotation.x));
            
            // Calculate camera position
            const distance = mapCamera.position.length();
            mapCamera.position.x = distance * Math.sin(cameraRotation.y) * Math.cos(cameraRotation.x);
            mapCamera.position.z = distance * Math.cos(cameraRotation.y) * Math.cos(cameraRotation.x);
            mapCamera.position.y = distance * Math.sin(cameraRotation.x);
            
            mapCamera.lookAt(0, 0, 0);
            
            previousMousePosition = {
                x: event.clientX,
                y: event.clientY
            };
        }
        
        function onDashboardMapMouseUp() {
            isDragging = false;
        }
        
        function onWindowResize() {
            const container = document.getElementById('map-container');
            mapCamera.aspect = container.clientWidth / container.clientHeight;
            mapCamera.updateProjectionMatrix();
            mapRenderer.setSize(container.clientWidth, container.clientHeight);
        }
        
        function fetchTimetableData() {
            const token = localStorage.getItem('access_token');
            
            // Demo data for testing
            const demoEvents = [
                {
                    "id": 1,
                    "title": "ENGGEN205 Lecture",
                    "event_type": "class",
                    "course": { "code": "ENGGEN205", "name": "Engineering Mechanics" },
                    "room": { "building": "ENG", "number": "340" },
                    "start_time": new Date().toISOString(),
                    "end_time": new Date(Date.now() + 3600000).toISOString(),
                    "lecturer": "Dr. Smith",
                    "is_urgent": false
                },
                {
                    "id": 2,
                    "title": "STATS100 Mid-term Exam",
                    "event_type": "exam",
                    "course": { "code": "STATS100", "name": "Statistics" },
                    "room": { "building": "ENG", "number": "401" },
                    "start_time": new Date(Date.now() + 86400000).toISOString(),
                    "end_time": new Date(Date.now() + 86400000 + 7200000).toISOString(),
                    "lecturer": "N/A",
                    "is_urgent": true
                }
            ];
            
            // For demo purposes, use the demo events directly
            renderFallbackTimetable(demoEvents);
        }
        
        function renderFallbackTimetable(events) {
            const timetable = document.getElementById('timetable');
            timetable.innerHTML = '';
            
            // Also update the full timetable if it exists
            const fullTimetable = document.getElementById('full-timetable');
            if (fullTimetable) {
                fullTimetable.innerHTML = '';
            }
            
            if (!events || events.length === 0) {
                const noEventsMessage = '<div class="empty-state">No events scheduled.</div>';
                timetable.innerHTML = noEventsMessage;
                if (fullTimetable) {
                    fullTimetable.innerHTML = noEventsMessage;
                }
                return;
            }
            
            events.forEach(event => {
                // Create timetable item for dashboard
                const item = createTimetableItem(event);
                timetable.appendChild(item);
                
                // Create duplicate for full timetable view if it exists
                if (fullTimetable) {
                    const fullItem = createTimetableItem(event);
                    fullTimetable.appendChild(fullItem);
                }
            });
        }
        
        function createTimetableItem(event) {
                const item = document.createElement('div');
                item.className = `timetable-item ${event.event_type === 'exam' ? 'exam' : ''}`;
                if (event.is_urgent) {
                    item.classList.add('urgent');
                }
                
                const startTime = new Date(event.start_time);
                const endTime = new Date(event.end_time);
            
            // Store building ID for navigation
            let buildingId = '';
            if (event.room && event.room.building) {
                switch(event.room.building) {
                    case 'ENG': buildingId = 'engineering'; break;
                    case 'SCI': buildingId = 'science'; break;
                    case 'LIB': buildingId = 'library'; break;
                    case 'BUS': buildingId = 'bizschool'; break;
                    case 'ARTS': buildingId = 'arts'; break;
                    case 'HSB': buildingId = 'health'; break;
                    default: buildingId = 'main';
                }
                item.dataset.buildingId = buildingId;
            }
                
                item.innerHTML = `
                    <div class="timetable-title">${event.title}</div>
                    <div class="timetable-info">
                        <div>${event.course ? event.course.code : 'N/A'} - ${event.room ? `${event.room.building} ${event.room.number}` : 'TBA'}</div>
                        <div>${startTime.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})} - ${endTime.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}</div>
                    </div>
                ${buildingId ? '<button class="navigate-btn">Navigate</button>' : ''}
            `;
            
            // Add click handler for navigation button
            if (buildingId) {
                const navigateBtn = item.querySelector('.navigate-btn');
                navigateBtn.addEventListener('click', function(e) {
                    e.stopPropagation(); // Prevent parent item click
                    navigateToBuilding(buildingId);
                });
            }
            
            // Make entire item clickable to view details
            item.addEventListener('click', function() {
                showEventDetails(event);
            });
            
            return item;
        }
        
        function navigateToBuilding(buildingId) {
            // Switch to map view
            document.querySelector('.event-item[data-view="map-view"]').click();
            
            // Wait for map to initialize if needed
            setTimeout(() => {
                // Make sure any previous selection is cleared
                if (selectedBuilding) {
                    const prevBuilding = window.campusBuildings[selectedBuilding];
                    if (prevBuilding && prevBuilding.mesh) {
                        prevBuilding.mesh.material.color.setHex(prevBuilding.mesh.userData.originalColor);
                        prevBuilding.mesh.material.emissive.setHex(0x000000);
                    }
                    selectedBuilding = null;
                }
                
                // Clear any existing routes
                clearRoute();
                
                // Force update the building selection UI
                const buttons = document.querySelectorAll('.building-option');
                buttons.forEach(btn => btn.classList.remove('selected'));
                
                const selectedButton = document.querySelector(`.building-option[data-building-id="${buildingId}"]`);
                if (selectedButton) {
                    selectedButton.classList.add('selected');
                }
                
                // Get building data and show route
                const building = window.campusBuildings[buildingId];
                if (building) {
                    selectDestination(buildingId, building.data.name);
                    
                    // Flash a highlight on the destination
                    const mesh = building.mesh;
                    if (mesh) {
                        const originalEmissiveColor = mesh.material.emissive.getHex();
                        mesh.material.emissive.setHex(0xff0000);
                        setTimeout(() => {
                            mesh.material.emissive.setHex(0x1f3a93);
                        }, 500);
                    }
                }
            }, 500);
        }
        
        function showStatusMessage(message, isError = false) {
            const statusEl = document.getElementById('status-message');
            statusEl.textContent = message;
            statusEl.classList.toggle('error', isError);
            statusEl.classList.add('show');
            
            setTimeout(() => {
                statusEl.classList.remove('show');
            }, 3000);
        }

        function setupNavigation() {
            // Get all navigation items
            const navItems = document.querySelectorAll('.event-item[data-view]');
            
            // Add click event to each item
            navItems.forEach(item => {
                item.addEventListener('click', function() {
                    // Remove active class from all items
                    navItems.forEach(navItem => navItem.classList.remove('active'));
                    
                    // Add active class to clicked item
                    this.classList.add('active');
                    
                    // Get the view to show
                    const viewId = this.getAttribute('data-view');
                    
                    // Hide all views
                    const views = document.querySelectorAll('.view-container');
                    views.forEach(view => view.classList.remove('active'));
                    
                    // Show selected view
                    document.getElementById(viewId).classList.add('active');
                    
                    // Special handling for map view
                    if (viewId === 'map-view') {
                        // Initialize fullscreen map if not already done
                        if (!document.querySelector('#fullscreen-map-container canvas')) {
                            initFullscreenMap();
                        }
                    }
                    
                    // Special handling for timetable view
                    if (viewId === 'timetable-view') {
                        // If we've added event listeners to full timetable items already, we're done
                        if (document.querySelector('#full-timetable .navigate-btn')) return;
                        
                        // Copy timetable data to full timetable view
                        const fullTimetable = document.getElementById('full-timetable');
                        const timetable = document.getElementById('timetable');
                        
                        // Only copy if the source timetable has content
                        if (timetable.children.length > 0 && !timetable.querySelector('.loading-indicator')) {
                            // The full timetable items are already created in renderFallbackTimetable
                            // using the same createTimetableItem function, so no additional work needed
                        } else {
                            // If no data yet, show loading and fetch data again
                            fetchTimetableData();
                        }
                    }
                });
            });
            
            // Initialize reset view button for the map
            const resetViewButton = document.getElementById('reset-view-btn');
            if (resetViewButton) {
                resetViewButton.addEventListener('click', function() {
                    // Reset camera position
                    if (fullscreenMapCamera) {
                        fullscreenMapCamera.position.set(0, 15, 20);
                        fullscreenMapCamera.lookAt(0, 0, 0);
                        fullscreenCameraRotation = { x: 0, y: 0 };
                    }
                });
            }
        }

        function initFullscreenMap() {
            const container = document.getElementById('fullscreen-map-container');
            
            // Create scene
            fullscreenMapScene = new THREE.Scene();
            fullscreenMapScene.background = new THREE.Color(0x1a1a1a);
            
            // Create camera
            fullscreenMapCamera = new THREE.PerspectiveCamera(60, container.clientWidth / container.clientHeight, 0.1, 1000);
            fullscreenMapCamera.position.set(0, 15, 20);
            fullscreenMapCamera.lookAt(0, 0, 0);
            
            // Create renderer
            fullscreenMapRenderer = new THREE.WebGLRenderer({ antialias: true });
            fullscreenMapRenderer.setSize(container.clientWidth, container.clientHeight);
            fullscreenMapRenderer.setPixelRatio(window.devicePixelRatio);
            fullscreenMapRenderer.shadowMap.enabled = true;
            container.appendChild(fullscreenMapRenderer.domElement);
            
            // Add lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            fullscreenMapScene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 10, 5);
            directionalLight.castShadow = true;
            fullscreenMapScene.add(directionalLight);
            
            // Create the campus model
            createFullscreenCampusModel();
            
            // Add event listeners
            container.addEventListener('mousedown', onFullscreenMapMouseDown);
            document.addEventListener('mousemove', onFullscreenMapMouseMove);
            document.addEventListener('mouseup', onFullscreenMapMouseUp);
            window.addEventListener('resize', onFullscreenWindowResize);
            
            // Create tooltip element if not exists
            if (!document.getElementById('map-tooltip')) {
                const tooltip = document.createElement('div');
                tooltip.id = 'map-tooltip';
                tooltip.style.position = 'fixed';
                tooltip.style.backgroundColor = 'rgba(0,0,0,0.7)';
                tooltip.style.color = 'white';
                tooltip.style.padding = '5px 10px';
                tooltip.style.borderRadius = '3px';
                tooltip.style.fontSize = '12px';
                tooltip.style.display = 'none';
                tooltip.style.zIndex = '1000';
                document.body.appendChild(tooltip);
            }
            
            // Populate building list
            populateBuildingList();
            
            // Start animation
            animateFullscreenMap();
        }

        function createFullscreenCampusModel() {
            // Create more realistic ground with grass texture
            createDetailedGround();
            
            // Campus buildings - layout matching the provided image
            const buildings = [
                { id: 'main', name: 'Main Building', x: 0, z: 0, width: 4, depth: 3, height: 2, color: 0xedeade, style: 'modern' },
                { id: 'library', name: 'Joseph G. Jabbra Library', x: -8, z: 0, width: 3, depth: 3, height: 1.8, color: 0xeae6ca, style: 'classic' },
                { id: 'science', name: 'Science Building', x: 6, z: -5, width: 3, depth: 2.5, height: 1.5, color: 0xe8e4c9, style: 'modern' },
                { id: 'engineering', name: 'Engineering Laboratories', x: -5, z: 6, width: 4, depth: 2, height: 2, color: 0xece5ce, style: 'complex' },
                { id: 'bizschool', name: 'Business School', x: 8, z: 6, width: 5, depth: 3, height: 3, color: 0xeee9d9, style: 'modern' },
                { id: 'student_center', name: 'Student Center', x: 0, z: -8, width: 6, depth: 4, height: 1, color: 0xebe3cf, style: 'modern' },
                { id: 'admin', name: 'Central Administration', x: -6, z: -6, width: 3, depth: 5, height: 2, color: 0xeae3d0, style: 'classic' },
                { id: 'architecture', name: 'Architecture Hall', x: 10, z: 0, width: 3, depth: 2, height: 2.2, color: 0xe5dfd0, style: 'complex' },
                { id: 'health', name: 'Health Sciences Center', x: 7, z: -9, width: 2.5, depth: 2.5, height: 2, color: 0xe9e4d1, style: 'modern' },
                { id: 'residence', name: 'Residence Hall Block B', x: 5, z: 12, width: 7, depth: 3, height: 1.5, color: 0xeee5d0, style: 'residential' }
            ];
            
            // Store building references for interaction
            window.campusBuildings = {};
            
            // Create all buildings
            buildings.forEach(building => {
                const buildingMesh = createFullscreenBuilding(
                    building.x, 
                    building.z, 
                    building.width, 
                    building.depth, 
                    building.height, 
                    building.color, 
                    building.name,
                    building.id,
                    building.style
                );
                
                // Store reference for interaction
                window.campusBuildings[building.id] = {
                    mesh: buildingMesh,
                    data: building
                };
            });
            
            // Add landscape elements
            addLandscapeElements();
            
            // Roads - create paths between buildings as in the image
            createCampusRoads();
        }

        function createDetailedGround() {
            // Main ground plane with grass texture
            const groundSize = 60;
            const textureLoader = new THREE.TextureLoader();
            
            // Create a canvas for the ground texture
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 512;
            canvas.height = 512;
            
            // Fill with base color
            ctx.fillStyle = '#8BC34A';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Add some texture/noise
            for (let i = 0; i < 5000; i++) {
                const x = Math.random() * canvas.width;
                const y = Math.random() * canvas.height;
                const radius = Math.random() * 2 + 1;
                const color = Math.random() > 0.5 ? '#7CB342' : '#9CCC65';
                
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);
                ctx.fillStyle = color;
                ctx.fill();
            }
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(10, 10);
            
            const groundMaterial = new THREE.MeshStandardMaterial({
                map: texture,
                roughness: 0.8,
                metalness: 0.1
            });
            
            const groundGeometry = new THREE.PlaneGeometry(groundSize, groundSize, 32, 32);
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = -0.1;
            fullscreenMapScene.add(ground);
            
            // Add terrain variations
            const heightField = new Float32Array(33 * 33);
            let i = 0;
            for (let y = 0; y < 33; y++) {
                for (let x = 0; x < 33; x++) {
                    const distance = Math.sqrt(Math.pow(x - 16, 2) + Math.pow(y - 16, 2));
                    const height = Math.max(0, 1 - distance / 16) * 0.5;
                    heightField[i++] = height;
                }
            }
            
            const terrainGeometry = new THREE.PlaneGeometry(groundSize, groundSize, 32, 32);
            const vertices = terrainGeometry.attributes.position.array;
            
            for (let i = 0, j = 0; i < vertices.length; i += 3, j++) {
                vertices[i + 2] = heightField[j] * 1.5;
            }
            
            terrainGeometry.computeVertexNormals();
            
            const terrainMaterial = new THREE.MeshStandardMaterial({
                map: texture,
                roughness: 0.9,
                metalness: 0.1,
                wireframe: false
            });
            
            const terrain = new THREE.Mesh(terrainGeometry, terrainMaterial);
            terrain.rotation.x = -Math.PI / 2;
            terrain.position.y = -0.2;
            fullscreenMapScene.add(terrain);
        }

        function addWindowsToFloor(floorGroup, width, depth, height) {
            // Window material
            const windowMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x90BBDB, 
                metalness: 0.9,
                roughness: 0.1,
                transparent: true,
                opacity: 0.7
            });
            
            // Window dimensions
            const windowWidth = 0.3;
            const windowHeight = 0.4;
            const windowDepth = 0.05;
            
            const frontWindowZ = depth / 2 + 0.01;
            const backWindowZ = -depth / 2 - 0.01;
            
            // Add windows on all sides
            for (let i = -1; i <= 1; i += 0.5) {
                // Skip center window on front side
                if (i !== 0) {
                    // Front windows
                    const frontWindowGeometry = new THREE.BoxGeometry(windowWidth, windowHeight, windowDepth);
                    const frontWindow = new THREE.Mesh(frontWindowGeometry, windowMaterial);
                    frontWindow.position.set(i * (width * 0.3), height * 0.5, frontWindowZ);
                    floorGroup.add(frontWindow);
                    
                    // Back windows
                    const backWindowGeometry = new THREE.BoxGeometry(windowWidth, windowHeight, windowDepth);
                    const backWindow = new THREE.Mesh(backWindowGeometry, windowMaterial);
                    backWindow.position.set(i * (width * 0.3), height * 0.5, backWindowZ);
                    floorGroup.add(backWindow);
                }
                
                // Side windows (only on sides)
                if (i !== 0) {
                    const rightWindowX = width / 2 + 0.01;
                    const leftWindowX = -width / 2 - 0.01;
                    
                    // Right windows
                    const rightWindowGeometry = new THREE.BoxGeometry(windowDepth, windowHeight, windowWidth);
                    const rightWindow = new THREE.Mesh(rightWindowGeometry, windowMaterial);
                    rightWindow.position.set(rightWindowX, height * 0.5, i * (depth * 0.3));
                    floorGroup.add(rightWindow);
                    
                    // Left windows
                    const leftWindowGeometry = new THREE.BoxGeometry(windowDepth, windowHeight, windowWidth);
                    const leftWindow = new THREE.Mesh(leftWindowGeometry, windowMaterial);
                    leftWindow.position.set(leftWindowX, height * 0.5, i * (depth * 0.3));
                    floorGroup.add(leftWindow);
                }
            }
        }

        function toggleFloorVisibility(buildingGroup, floorIndex) {
            // Only work if building is expanded
            if (!buildingGroup.userData.isExpanded) {
                toggleBuildingExpansion(buildingGroup);
                return;
            }
            
            const floor = buildingGroup.userData.floors[floorIndex];
            const floorMesh = floor.children[0];
            
            // Toggle visibility of this floor's rooms
            const isCurrentlyVisible = floorMesh.userData.isVisible;
            
            // Find all room meshes in this floor
            floor.traverse(child => {
                if (child.userData && child.userData.type === 'room') {
                    child.visible = !isCurrentlyVisible;
                }
            });
            
            // Update state
            floorMesh.userData.isVisible = !isCurrentlyVisible;
            
            // Show status message
            showStatusMessage(isCurrentlyVisible ? 
                `Hiding rooms on Floor ${floorIndex + 1}` : 
                `Showing rooms on Floor ${floorIndex + 1}`);
        }

        function toggleBuildingExpansion(buildingGroup) {
            const buildingData = buildingGroup.userData;
            const isExpanding = !buildingData.isExpanded;
            const expandedScale = buildingData.expandedScale;
            const duration = 1000; // 1 second animation
            
            // Set new target positions for floors
            if (isExpanding) {
                // When expanding, spread floors vertically
                buildingData.floors.forEach((floor, i) => {
                    const targetY = i * expandedScale;
                    
                    // Animate floor position
                    const startY = floor.position.y;
                    const startTime = Date.now();
                    
                    function animateFloorExpand() {
                        const elapsed = Date.now() - startTime;
                        const progress = Math.min(elapsed / duration, 1);
                        
                        // Ease in-out function
                        const easeProgress = progress < 0.5 
                            ? 2 * progress * progress 
                            : 1 - Math.pow(-2 * progress + 2, 2) / 2;
                        
                        floor.position.y = startY + (targetY - startY) * easeProgress;
                        
                        if (progress < 1) {
                            requestAnimationFrame(animateFloorExpand);
                        } else {
                            // Animation complete
                            floor.position.y = targetY;
                        }
                    }
                    
                    animateFloorExpand();
                });
            } else {
                // When collapsing, return floors to original positions
                buildingData.floors.forEach((floor, i) => {
                    const targetY = i * (buildingData.floors[0].children[0].geometry.parameters.height * 0.95);
                    
                    // Animate floor position
                    const startY = floor.position.y;
                    const startTime = Date.now();
                    
                    function animateFloorCollapse() {
                        const elapsed = Date.now() - startTime;
                        const progress = Math.min(elapsed / duration, 1);
                        
                        // Ease in-out function
                        const easeProgress = progress < 0.5 
                            ? 2 * progress * progress 
                            : 1 - Math.pow(-2 * progress + 2, 2) / 2;
                        
                        floor.position.y = startY + (targetY - startY) * easeProgress;
                        
                        if (progress < 1) {
                            requestAnimationFrame(animateFloorCollapse);
                        } else {
                            // Animation complete
                            floor.position.y = targetY;
                            
                            // Hide all room meshes when collapsed
                            floor.traverse(child => {
                                if (child.userData && child.userData.type === 'room') {
                                    child.visible = false;
                                }
                            });
                        }
                    }
                    
                    animateFloorCollapse();
                });
            }
            
            // Update building state
            buildingData.isExpanded = isExpanding;
            
            // Update tooltip with new state
            const tooltip = document.getElementById('map-tooltip');
            if (tooltip && tooltip.style.display === 'block') {
                const buildingName = buildingData.name;
                const expansionState = isExpanding ? "Expanded" : "Collapsed";
                tooltip.textContent = `${buildingName} (${expansionState})`;
            }
            
            // Show status message
            showStatusMessage(isExpanding ? 
                `Expanded ${buildingData.name}` : 
                `Collapsed ${buildingData.name}`);
        }

        function createBuildingLabel(x, y, z, text) {
            // Create canvas for text
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 256;
            canvas.height = 64;
            
            // Set up text style
            context.fillStyle = 'rgba(0, 0, 0, 0.85)';
            context.fillRect(0, 0, canvas.width, canvas.height);
            
            // Add a border
            context.strokeStyle = '#1f3a93';
            context.lineWidth = 3;
            context.strokeRect(2, 2, canvas.width-4, canvas.height-4);
            
            // Add text
            context.font = 'bold 24px Arial';
            context.fillStyle = 'white';
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillText(text, canvas.width / 2, canvas.height / 2);
            
            // Create texture from canvas
            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.SpriteMaterial({ 
                map: texture,
                transparent: true,
                opacity: 0.9
            });
            const sprite = new THREE.Sprite(material);
            
            // Position and scale the label
            sprite.position.set(x, y, z);
            sprite.scale.set(3, 0.8, 1);
            
            // Add to scene
            fullscreenMapScene.add(sprite);
            
            // Store original y position for animation
            sprite.userData = { originalY: y };
            
            // Add to animation objects for floating effect
            if (!window.animatedLabels) window.animatedLabels = [];
            window.animatedLabels.push(sprite);
            
            return sprite;
        }

        // Array to store interactive objects
        let interactiveObjects = [];
        let selectedBuilding = null;
        let currentRoute = null;
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();
        let currentUserPosition = { x: 0, z: -12 }; // Default position near entrance
        
        function selectDashboardDestination(buildingId, buildingName) {
            // Clear any existing routes first
            if (dashboardCurrentRoute) {
                mapScene.remove(dashboardCurrentRoute);
                if (dashboardCurrentRoute.userData && dashboardCurrentRoute.userData.markers) {
                    dashboardCurrentRoute.userData.markers.forEach(marker => {
                        mapScene.remove(marker);
                    });
                }
                dashboardCurrentRoute = null;
            }
            
            // Deselect previous building if any
            if (dashboardSelectedBuilding) {
                const prevBuilding = window.dashboardBuildings[dashboardSelectedBuilding];
                if (prevBuilding && prevBuilding.mesh) {
                    prevBuilding.mesh.material.color.setHex(prevBuilding.mesh.userData.originalColor);
                    prevBuilding.mesh.material.emissive.setHex(0x000000);
                }
            }
            
            // Select new building
            dashboardSelectedBuilding = buildingId;
            const building = window.dashboardBuildings[buildingId];
            
            if (building && building.mesh) {
                // Highlight selected building
                building.mesh.material.emissive.setHex(0x1f3a93);
                
                // Show selection in UI
                showStatusMessage(`Selected destination: ${buildingName}`);
                
                // Update destination display in UI
                const destinationElement = document.getElementById('dashboard-selected-destination');
                if (destinationElement) {
                    destinationElement.textContent = buildingName;
                }
                
                // Calculate and show route
                dashboardCurrentRoute = calculateDashboardRoute({ x: 0, z: -12 }, {
                    x: building.data.x,
                    z: building.data.z
                });
                
                // Update building list selection
                const buttons = document.querySelectorAll('#dashboard-building-list .building-option');
                buttons.forEach(btn => btn.classList.remove('selected'));
                
                const selectedButton = document.querySelector(`#dashboard-building-list .building-option[data-building-id="${buildingId}"]`);
                if (selectedButton) {
                    selectedButton.classList.add('selected');
                }
            }
        }
        
        function selectDashboardBuildingFromList(buildingId) {
            // Update button styles
            const buttons = document.querySelectorAll('#dashboard-building-list .building-option');
            
            // If selecting the same building, toggle selection off
            if (dashboardSelectedBuilding === buildingId) {
                // Deselect the building
                buttons.forEach(btn => btn.classList.remove('selected'));
                
                // Find the building and reset its appearance
                const building = window.dashboardBuildings[buildingId];
                if (building && building.mesh) {
                    building.mesh.material.emissive.setHex(0x000000);
                }
                
                // Clear route
                if (dashboardCurrentRoute) {
                    // Remove the route line
                    mapScene.remove(dashboardCurrentRoute);
                    
                    // Remove any associated markers
                    if (dashboardCurrentRoute.userData && dashboardCurrentRoute.userData.markers) {
                        dashboardCurrentRoute.userData.markers.forEach(marker => {
                            mapScene.remove(marker);
                        });
                    }
                    
                    dashboardCurrentRoute = null;
                }
                
                // Reset destination
                const destinationElement = document.getElementById('dashboard-selected-destination');
                if (destinationElement) {
                    destinationElement.textContent = 'Select a building';
                }
                
                // Reset distance info
                const distanceInfo = document.getElementById('dashboard-distance-info');
                if (distanceInfo) {
                    distanceInfo.textContent = '';
                }
                
                // Reset selection tracking
                dashboardSelectedBuilding = null;
                showStatusMessage('Route cleared');
                return;
            }
            
            // Otherwise, proceed with selection
            buttons.forEach(btn => btn.classList.remove('selected'));
            
            const selectedButton = document.querySelector(`#dashboard-building-list .building-option[data-building-id="${buildingId}"]`);
            if (selectedButton) {
                selectedButton.classList.add('selected');
            }
            
            // Get building data and call select function
            const building = window.dashboardBuildings[buildingId];
            if (building) {
                selectDashboardDestination(buildingId, building.data.name);
            }
        }
        
        function calculateDashboardRoute(from, to) {
            // Generate a random color for this route
            const routeColor = Math.floor(Math.random() * 0xffffff);
            
            // Create a simple route (in real app this would use pathfinding)
            const points = [
                new THREE.Vector3(from.x, 0.1, from.z),
                new THREE.Vector3((from.x + to.x) / 2, 0.1, from.z),
                new THREE.Vector3((from.x + to.x) / 2, 0.1, to.z),
                new THREE.Vector3(to.x, 0.1, to.z)
            ];
            
            // Create a smooth path with a curve
            const curve = new THREE.CatmullRomCurve3(points);
            const routePoints = curve.getPoints(50);
            
            // Create line geometry for the route
            const routeGeometry = new THREE.BufferGeometry().setFromPoints(routePoints);
            
            // Create line material with the random color
            const routeMaterial = new THREE.LineBasicMaterial({
                color: routeColor,
                linewidth: 3
            });
            
            // Create the line and add to scene
            const routeLine = new THREE.Line(routeGeometry, routeMaterial);
            routeLine.userData = { 
                color: routeColor,
                markers: [],
                buildingId: dashboardSelectedBuilding
            };
            
            // Make sure line is visible by setting position high enough
            routeLine.position.y = 0.2;
            
            // Add to scene
            mapScene.add(routeLine);
            
            // Add start and end markers
            const startMarker = createDashboardLocationMarker(from.x, from.z);
            routeLine.userData.markers.push(startMarker);
            
            const endMarker = createDashboardDestinationMarker(to.x, to.z);
            routeLine.userData.markers.push(endMarker);
            
            // Calculate and show distance with more realistic walking time
            const distance = calculateDistance(from, to);
            const walkingSpeed = 1.4; // meters per second
            const walkingTimeSeconds = distance / walkingSpeed;
            const walkingTimeMinutes = Math.max(2, Math.min(10, Math.ceil(walkingTimeSeconds / 60)));
            
            const distanceInfo = document.getElementById('dashboard-distance-info');
            if (distanceInfo) {
                distanceInfo.textContent = `Distance: ${Math.round(distance)} m â€¢ Walking: ${walkingTimeMinutes} min`;
            }
            
            return routeLine;
        }
        
        function createDashboardLocationMarker(x, z) {
            const markerGeometry = new THREE.CylinderGeometry(0.3, 0.3, 0.2, 16);
            const markerMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
            const marker = new THREE.Mesh(markerGeometry, markerMaterial);
            marker.position.set(x, 0.2, z);
            mapScene.add(marker);
            return marker;
        }
        
        function createDashboardDestinationMarker(x, z) {
            const markerGeometry = new THREE.CylinderGeometry(0.3, 0, 0.5, 16);
            const markerMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            const marker = new THREE.Mesh(markerGeometry, markerMaterial);
            marker.position.set(x, 0.3, z);
            mapScene.add(marker);
            return marker;
        }
        
        function calculateDistance(from, to) {
            // Simple Euclidean distance, multiplied by 5 to approximate realistic campus distances in meters
            const dx = to.x - from.x;
            const dz = to.z - from.z;
            return Math.sqrt(dx * dx + dz * dz) * 5;
        }
        
        function createLocationMarker(x, z) {
            const markerGeometry = new THREE.CylinderGeometry(0.3, 0.3, 0.2, 16);
            const markerMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
            const marker = new THREE.Mesh(markerGeometry, markerMaterial);
            marker.position.set(x, 0.2, z);
            fullscreenMapScene.add(marker);
            
            // Add to current route objects for cleanup
            if (!currentRoute.userData) currentRoute.userData = {};
            if (!currentRoute.userData.markers) currentRoute.userData.markers = [];
            currentRoute.userData.markers.push(marker);
        }
        
        function createDestinationMarker(x, z) {
            const markerGeometry = new THREE.CylinderGeometry(0.3, 0, 0.5, 16);
            const markerMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            const marker = new THREE.Mesh(markerGeometry, markerMaterial);
            marker.position.set(x, 0.3, z);
            fullscreenMapScene.add(marker);
            
            // Add to current route objects for cleanup
            if (!currentRoute.userData) currentRoute.userData = {};
            if (!currentRoute.userData.markers) currentRoute.userData.markers = [];
            currentRoute.userData.markers.push(marker);
        }
        
        function clearRoute() {
            if (currentRoute) {
                // Remove the route line
                fullscreenMapScene.remove(currentRoute);
                
                // Remove any associated markers
                if (currentRoute.userData && currentRoute.userData.markers) {
                    currentRoute.userData.markers.forEach(marker => {
                        fullscreenMapScene.remove(marker);
                    });
                }
                
                currentRoute = null;
            }
        }

        function onFullscreenMapMouseDown(event) {
            // Handle drag start for camera rotation
            isFullscreenDragging = true;
            fullscreenPreviousMousePosition = {
                x: event.clientX,
                y: event.clientY
            };
            
            // Handle object selection on click
            event.preventDefault();
            
            // Get normalized device coordinates
            const container = document.getElementById('fullscreen-map-container');
            const rect = container.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / container.clientWidth) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / container.clientHeight) * 2 + 1;
            
            // Update the raycaster
            raycaster.setFromCamera(mouse, fullscreenMapCamera);
            
            // Check for intersections with interactive objects
            const intersects = raycaster.intersectObjects(interactiveObjects);
            
            if (intersects.length > 0) {
                // Prevent unintended camera rotation when clicking on objects
                isFullscreenDragging = false;
                
                // Call the callback function of the intersected object
                if (intersects[0].object.callback) {
                    intersects[0].object.callback();
                }
            }
        }

        function onFullscreenMapMouseMove(event) {
            // Handle camera rotation if dragging
            if (isFullscreenDragging) {
                const deltaMove = {
                    x: event.clientX - fullscreenPreviousMousePosition.x,
                    y: event.clientY - fullscreenPreviousMousePosition.y
                };
                
                // Rotate camera based on mouse movement
                fullscreenCameraRotation.y += deltaMove.x * 0.01;
                fullscreenCameraRotation.x += deltaMove.y * 0.01;
                
                // Limit vertical rotation
                fullscreenCameraRotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, fullscreenCameraRotation.x));
                
                // Calculate camera position
                const distance = fullscreenMapCamera.position.length();
                fullscreenMapCamera.position.x = distance * Math.sin(fullscreenCameraRotation.y) * Math.cos(fullscreenCameraRotation.x);
                fullscreenMapCamera.position.z = distance * Math.cos(fullscreenCameraRotation.y) * Math.cos(fullscreenCameraRotation.x);
                fullscreenMapCamera.position.y = distance * Math.sin(fullscreenCameraRotation.x);
                
                fullscreenMapCamera.lookAt(0, 0, 0);
                
                fullscreenPreviousMousePosition = {
                    x: event.clientX,
                    y: event.clientY
                };
                return;
            }
            
            // Handle hover effect for interactive objects
            const container = document.getElementById('fullscreen-map-container');
            const rect = container.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / container.clientWidth) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / container.clientHeight) * 2 + 1;
            
            // Update the raycaster
            raycaster.setFromCamera(mouse, fullscreenMapCamera);
            
            // Check for intersections with interactive objects
            const intersects = raycaster.intersectObjects(interactiveObjects, true);
            
            // Reset all buildings to original color (except selected)
            interactiveObjects.forEach(obj => {
                if (selectedBuilding && obj.userData && obj.userData.id === selectedBuilding) return;
                if (obj.material) obj.material.emissive.setHex(0x000000);
            });
            
            // Hide tooltip by default
            const tooltip = document.getElementById('map-tooltip');
            if (tooltip) {
                tooltip.style.display = 'none';
            }
            
            // Show tooltip and highlight hovered object
            if (intersects.length > 0) {
                document.body.style.cursor = 'pointer';
                const intersectedObject = intersects[0].object;
                
                // Get parent building if it's a floor or room
                let building = intersectedObject;
                
                // Find the parent building group
                let parentGroup = intersectedObject;
                while (parentGroup && !(parentGroup.userData && parentGroup.userData.floors)) {
                    parentGroup = parentGroup.parent;
                }
                
                // If we found a building group
                if (parentGroup && parentGroup.userData) {
                    const buildingData = parentGroup.userData;
                    
                    // Don't highlight if it's the selected building
                    if (!selectedBuilding || intersectedObject.userData.id !== selectedBuilding) {
                        // Highlight the object or building component
                        if (intersectedObject.material) {
                            intersectedObject.material.emissive.setHex(0x333333);
                        }
                    }
                    
                    // Different tooltip info based on what was intersected
                    if (tooltip) {
                        let tooltipContent = '';
                        
                        // If it's a room
                        if (intersectedObject.userData && intersectedObject.userData.type === 'room') {
                            tooltipContent = `${intersectedObject.userData.name}<br>Building: ${buildingData.name}`;
                        }
                        // If it's a floor
                        else if (intersectedObject.userData && intersectedObject.userData.floorIndex !== undefined) {
                            const floorIndex = intersectedObject.userData.floorIndex;
                            const isExpanded = buildingData.isExpanded;
                            const roomVisibility = intersectedObject.userData.isVisible ? 'Visible' : 'Hidden';
                            
                            tooltipContent = `${buildingData.name} - Floor ${floorIndex+1}<br>`;
                            
                            if (isExpanded) {
                                tooltipContent += `Rooms: ${roomVisibility} (Click to toggle)`;
                            } else {
                                tooltipContent += `Click to expand building`;
                            }
                        }
                        // Otherwise it's the building itself
                        else {
                            const expansionState = buildingData.isExpanded ? "Expanded" : "Click to expand";
                            tooltipContent = `${buildingData.name}<br>${expansionState}`;
                        }
                        
                        tooltip.innerHTML = tooltipContent;
                        tooltip.style.left = (event.clientX + 10) + 'px';
                        tooltip.style.top = (event.clientY + 10) + 'px';
                        tooltip.style.display = 'block';
                    }
                } else {
                    // Standard behavior for non-building objects
                    if (intersectedObject.userData && intersectedObject.userData.name) {
                        if (tooltip) {
                            tooltip.innerHTML = intersectedObject.userData.name;
                            tooltip.style.left = (event.clientX + 10) + 'px';
                            tooltip.style.top = (event.clientY + 10) + 'px';
                            tooltip.style.display = 'block';
                        }
                        
                        if (intersectedObject.material) {
                            intersectedObject.material.emissive.setHex(0x333333);
                        }
                    }
                }
            } else {
                document.body.style.cursor = 'default';
            }
        }

        function onFullscreenMapMouseUp() {
            isFullscreenDragging = false;
        }

        function onFullscreenWindowResize() {
            const container = document.getElementById('fullscreen-map-container');
            fullscreenMapCamera.aspect = container.clientWidth / container.clientHeight;
            fullscreenMapCamera.updateProjectionMatrix();
            fullscreenMapRenderer.setSize(container.clientWidth, container.clientHeight);
        }

        function animateFullscreenMap() {
            requestAnimationFrame(animateFullscreenMap);
            
            // Animate building labels (floating effect)
            if (window.animatedLabels && window.animatedLabels.length > 0) {
                const time = Date.now() * 0.001;
                window.animatedLabels.forEach(label => {
                    if (label && label.userData && label.userData.originalY) {
                        label.position.y = label.userData.originalY + Math.sin(time * 1.5) * 0.05;
                    }
                });
            }
            
            if (fullscreenMapRenderer) {
                fullscreenMapRenderer.render(fullscreenMapScene, fullscreenMapCamera);
            }
        }

        // Initialize the app on load
        window.addEventListener('DOMContentLoaded', function() {
            // Set up variables
            cameraRotation = { x: 0, y: 0 };
            fullscreenCameraRotation = { x: 0, y: 0 };
            isDragging = false;
            
            // Initialize dashboard
            setupNavigation();
            fetchTimetableData();
            initDashboardMap();
            
            // Set up logout functionality
            document.getElementById('logout-button').addEventListener('click', function() {
                logoutUser();
            });
            
            // Initialize building list once map view is active
            document.querySelector('.event-item[data-view="map-view"]').addEventListener('click', function() {
                setTimeout(populateBuildingList, 500);
            });
        });
        
        function populateBuildingList() {
            const buildingList = document.getElementById('building-list');
            if (!buildingList) return;
            
            buildingList.innerHTML = '';
            
            // Campus buildings data - must match the data in createFullscreenCampusModel
            const buildings = [
                { id: 'main', name: 'Main Building' },
                { id: 'library', name: 'Library' },
                { id: 'science', name: 'Science Block' },
                { id: 'engineering', name: 'Engineering Building' },
                { id: 'bizschool', name: 'Business School' },
                { id: 'student_center', name: 'Student Center' },
                { id: 'general', name: 'General Building' },
                { id: 'arts', name: 'Arts Building' },
                { id: 'health', name: 'Health Sciences' }
            ];
            
            // Create buttons for all buildings
            buildings.forEach(building => {
                const button = document.createElement('button');
                button.className = 'building-option';
                if (selectedBuilding === building.id) {
                    button.classList.add('selected');
                }
                button.dataset.buildingId = building.id;
                button.textContent = building.name;
                
                // Add click handler to select building
                button.addEventListener('click', function() {
                    const buildingId = this.dataset.buildingId;
                    
                    // Update button styles first
                    const allButtons = document.querySelectorAll('.building-option');
                    
                    // If selecting the same building, toggle selection off
                    if (selectedBuilding === buildingId) {
                        // Deselect the building
                        allButtons.forEach(btn => btn.classList.remove('selected'));
                        
                        // Reset the 3D object appearance
                        const building = window.campusBuildings[buildingId];
                        if (building && building.mesh) {
                            building.mesh.material.emissive.setHex(0x000000);
                        }
                        
                        // Clear associated route if any
                        clearRoute();
                        
                        // Reset destination text
                        const destinationElement = document.getElementById('selected-destination');
                        if (destinationElement) {
                            destinationElement.textContent = 'Select a building';
                        }
                        
                        // Reset distance info
                        const distanceInfo = document.getElementById('distance-info');
                        if (distanceInfo) {
                            distanceInfo.textContent = '';
                        }
                        
                        // Reset selection tracking
                        selectedBuilding = null;
                        showStatusMessage('Route cleared');
                        return;
                    }
                    
                    // Otherwise, proceed with selection
                    allButtons.forEach(btn => btn.classList.remove('selected'));
                    this.classList.add('selected');
                    
                    // Select the building in 3D scene
                    const building = window.campusBuildings[buildingId];
                    if (building) {
                        // Deselect previous building if any
                        if (selectedBuilding) {
                            const prevBuilding = window.campusBuildings[selectedBuilding];
                            if (prevBuilding && prevBuilding.mesh) {
                                prevBuilding.mesh.material.emissive.setHex(0x000000);
                            }
                        }
                        
                        // Clear previous routes
                        clearRoute();
                        
                        // Store new selected building
                        selectedBuilding = buildingId;
                        
                        // Highlight the building
                        building.mesh.material.emissive.setHex(0x1f3a93);
                        
                        // Show selection in UI
                        const name = building.data.name;
                        showStatusMessage(`Selected destination: ${name}`);
                        
                        // Update destination display in UI
                        const destinationElement = document.getElementById('selected-destination');
                        if (destinationElement) {
                            destinationElement.textContent = name;
                        }
                        
                        // Calculate and show route
                        currentRoute = calculateRoute(currentUserPosition, {
                            x: building.data.x,
                            z: building.data.z
                        });
                    }
                });
                
                buildingList.appendChild(button);
            });
            
            // Set up map control buttons
            setupMapControls();
        }
        
        function selectBuildingFromList(buildingId) {
            // Update button styles
            const buttons = document.querySelectorAll('.building-option');
            
            // If selecting the same building, toggle selection off
            if (selectedBuilding === buildingId) {
                // Deselect the building
                buttons.forEach(btn => btn.classList.remove('selected'));
                
                // Find the building and reset its appearance
                const building = window.campusBuildings[buildingId];
                if (building && building.mesh) {
                    building.mesh.material.emissive.setHex(0x000000);
                }
                
                // Clear associated route if any
                const linesToRemove = [];
                fullscreenMapScene.traverse(obj => {
                    if (obj.type === 'Line' && obj.userData && obj.userData.buildingId === buildingId) {
                        linesToRemove.push(obj);
                    }
                });
                
                linesToRemove.forEach(line => {
                    // Remove associated markers
                    if (line.userData && line.userData.markers) {
                        line.userData.markers.forEach(marker => {
                            fullscreenMapScene.remove(marker);
                        });
                    }
                    fullscreenMapScene.remove(line);
                });
                
                // Reset destination
                const destinationElement = document.getElementById('selected-destination');
                if (destinationElement) {
                    destinationElement.textContent = 'Select a building';
                }
                
                // Reset selection tracking
                selectedBuilding = null;
                showStatusMessage('Route cleared');
                return;
            }
            
            // Otherwise, proceed with selection
            buttons.forEach(btn => btn.classList.remove('selected'));
            
            const selectedButton = document.querySelector(`.building-option[data-building-id="${buildingId}"]`);
            if (selectedButton) {
                selectedButton.classList.add('selected');
            }
            
            // Get building data and call select function
            const building = window.campusBuildings[buildingId];
            if (building) {
                const name = building.data.name;
                
                // Deselect previous building if any
                if (selectedBuilding) {
                    const prevBuilding = window.campusBuildings[selectedBuilding];
                    if (prevBuilding && prevBuilding.mesh) {
                        prevBuilding.mesh.material.color.setHex(prevBuilding.mesh.userData.originalColor);
                        prevBuilding.mesh.material.emissive.setHex(0x000000);
                    }
                }
                
                // Select new building
                selectedBuilding = buildingId;
                
                // Highlight selected building
                building.mesh.material.emissive.setHex(0x1f3a93);
                
                // Show selection in UI
                showStatusMessage(`Selected destination: ${name}`);
                
                // Update destination display in UI
                const destinationElement = document.getElementById('selected-destination');
                if (destinationElement) {
                    destinationElement.textContent = name;
                }
                
                // Calculate and show route
                currentRoute = calculateRoute(currentUserPosition, {
                    x: building.data.x,
                    z: building.data.z
                });
            }
        }
        
        function setupMapControls() {
            // Zoom in button
            document.getElementById('zoom-in-btn').addEventListener('click', function() {
                const distance = fullscreenMapCamera.position.length();
                if (distance > 5) {
                    fullscreenMapCamera.position.multiplyScalar(0.8);
                }
            });
            
            // Zoom out button
            document.getElementById('zoom-out-btn').addEventListener('click', function() {
                const distance = fullscreenMapCamera.position.length();
                if (distance < 50) {
                    fullscreenMapCamera.position.multiplyScalar(1.2);
                }
            });
            
            // Reset view button
            document.getElementById('reset-view-btn').addEventListener('click', function() {
                fullscreenMapCamera.position.set(0, 15, 20);
                fullscreenMapCamera.lookAt(0, 0, 0);
                fullscreenCameraRotation = { x: 0, y: 0 };
            });
            
            // Top view button
            document.getElementById('top-view-btn').addEventListener('click', function() {
                fullscreenMapCamera.position.set(0, 30, 0.1);
                fullscreenMapCamera.lookAt(0, 0, 0);
                fullscreenCameraRotation = { x: Math.PI/2 - 0.01, y: 0 };
            });
            
            // Add a clear routes button to the map controls
            const mapControls = document.getElementById('map-controls');
            
            // Create clear routes button if it doesn't exist
            if (!document.getElementById('clear-routes-btn')) {
                const clearRoutesBtn = document.createElement('button');
                clearRoutesBtn.id = 'clear-routes-btn';
                clearRoutesBtn.className = 'map-control-btn';
                clearRoutesBtn.innerHTML = 'âœ•';
                clearRoutesBtn.title = 'Clear Routes';
                
                clearRoutesBtn.addEventListener('click', function() {
                    // Remove all routes from the scene (children of type Line)
                    const linesToRemove = [];
                    
                    fullscreenMapScene.traverse(obj => {
                        if (obj.type === 'Line') {
                            linesToRemove.push(obj);
                        }
                    });
                    
                    linesToRemove.forEach(line => {
                        // Remove associated markers
                        if (line.userData && line.userData.markers) {
                            line.userData.markers.forEach(marker => {
                                fullscreenMapScene.remove(marker);
                            });
                        }
                        fullscreenMapScene.remove(line);
                    });
                    
                    // Reset current route reference
                    currentRoute = null;
                    
                    // Reset distance info
                    const distanceInfo = document.getElementById('distance-info');
                    if (distanceInfo) {
                        distanceInfo.textContent = '';
                    }
                    
                    // Reset selected building
                    if (selectedBuilding) {
                        const prevBuilding = window.campusBuildings[selectedBuilding];
                        if (prevBuilding && prevBuilding.mesh) {
                            prevBuilding.mesh.material.color.setHex(prevBuilding.mesh.userData.originalColor);
                            prevBuilding.mesh.material.emissive.setHex(0x000000);
                        }
                        selectedBuilding = null;
                    }
                    
                    // Reset destination text
                    const destinationElement = document.getElementById('selected-destination');
                    if (destinationElement) {
                        destinationElement.textContent = 'Select a building';
                    }
                    
                    // Clear selected state from building buttons
                    document.querySelectorAll('.building-option').forEach(btn => {
                        btn.classList.remove('selected');
                    });
                    
                    showStatusMessage('All routes cleared');
                });
                
                mapControls.appendChild(clearRoutesBtn);
            }
        }

        function populateDashboardBuildingList() {
            const buildingList = document.getElementById('dashboard-building-list');
            if (!buildingList) return;
            
            buildingList.innerHTML = '';
            
            // Campus buildings data - must match the data in createDashboardCampusModel
            const buildings = [
                { id: 'main', name: 'Main Building' },
                { id: 'library', name: 'Library' },
                { id: 'science', name: 'Science Block' },
                { id: 'engineering', name: 'Engineering Building' },
                { id: 'bizschool', name: 'Business School' },
                { id: 'student_center', name: 'Student Center' },
                { id: 'general', name: 'General Building' },
                { id: 'arts', name: 'Arts Building' },
                { id: 'health', name: 'Health Sciences' }
            ];
            
            // Create buttons for all buildings
            buildings.forEach(building => {
                const button = document.createElement('button');
                button.className = 'building-option';
                if (dashboardSelectedBuilding === building.id) {
                    button.classList.add('selected');
                }
                button.dataset.buildingId = building.id;
                button.textContent = building.name;
                
                // Add click handler to select building
                button.addEventListener('click', function() {
                    const buildingId = this.dataset.buildingId;
                    
                    // Update button styles first
                    const allButtons = document.querySelectorAll('#dashboard-building-list .building-option');
                    
                    // If selecting the same building, toggle selection off
                    if (dashboardSelectedBuilding === buildingId) {
                        // Deselect the building
                        allButtons.forEach(btn => btn.classList.remove('selected'));
                        
                        // Reset the 3D object appearance
                        const building = window.dashboardBuildings[buildingId];
                        if (building && building.mesh) {
                            building.mesh.material.emissive.setHex(0x000000);
                        }
                        
                        // Clear associated route if any
                        if (dashboardCurrentRoute) {
                            mapScene.remove(dashboardCurrentRoute);
                            if (dashboardCurrentRoute.userData && dashboardCurrentRoute.userData.markers) {
                                dashboardCurrentRoute.userData.markers.forEach(marker => {
                                    mapScene.remove(marker);
                                });
                            }
                            dashboardCurrentRoute = null;
                        }
                        
                        // Reset destination text
                        const destinationElement = document.getElementById('dashboard-selected-destination');
                        if (destinationElement) {
                            destinationElement.textContent = 'Select a building';
                        }
                        
                        // Reset distance info
                        const distanceInfo = document.getElementById('dashboard-distance-info');
                        if (distanceInfo) {
                            distanceInfo.textContent = '';
                        }
                        
                        // Reset selection tracking
                        dashboardSelectedBuilding = null;
                        showStatusMessage('Route cleared');
                        return;
                    }
                    
                    // Otherwise, proceed with selection
                    allButtons.forEach(btn => btn.classList.remove('selected'));
                    this.classList.add('selected');
                    
                    // Get building data and create route
                    const building = window.dashboardBuildings[buildingId];
                    if (building) {
                        // Deselect previous building if any
                        if (dashboardSelectedBuilding) {
                            const prevBuilding = window.dashboardBuildings[dashboardSelectedBuilding];
                            if (prevBuilding && prevBuilding.mesh) {
                                prevBuilding.mesh.material.emissive.setHex(0x000000);
                            }
                        }
                        
                        // Clear any existing routes
                        if (dashboardCurrentRoute) {
                            mapScene.remove(dashboardCurrentRoute);
                            if (dashboardCurrentRoute.userData && dashboardCurrentRoute.userData.markers) {
                                dashboardCurrentRoute.userData.markers.forEach(marker => {
                                    mapScene.remove(marker);
                                });
                            }
                            dashboardCurrentRoute = null;
                        }
                        
                        // Store new selected building
                        dashboardSelectedBuilding = buildingId;
                        
                        // Highlight the building
                        building.mesh.material.emissive.setHex(0x1f3a93);
                        
                        // Show selection in UI
                        const name = building.data.name;
                        showStatusMessage(`Selected destination: ${name}`);
                        
                        // Update destination display in UI
                        const destinationElement = document.getElementById('dashboard-selected-destination');
                        if (destinationElement) {
                            destinationElement.textContent = name;
                        }
                        
                        // Calculate and show route
                        dashboardCurrentRoute = calculateDashboardRoute({ x: 0, z: -12 }, {
                            x: building.data.x,
                            z: building.data.z
                        });
                    }
                });
                
                buildingList.appendChild(button);
            });
        }

        function createDashboardCampusModel() {
            // Floor/ground - matching campus layout from image
            const floorGeometry = new THREE.PlaneGeometry(40, 40);
            const floorMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x95c795,
                roughness: 0.8
            });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.position.y = -0.1;
            mapScene.add(floor);
            
            // Campus buildings - same layout as fullscreen map
            const buildings = [
                { id: 'main', name: 'Main Building', x: 0, z: 0, width: 4, depth: 3, height: 2, color: 0x555555 },
                { id: 'library', name: 'Library', x: -8, z: 0, width: 3, depth: 3, height: 1.8, color: 0x5A6377 },
                { id: 'science', name: 'Science Block', x: 6, z: -5, width: 3, depth: 2.5, height: 1.5, color: 0x4C6A73 },
                { id: 'engineering', name: 'Engineering Building', x: -5, z: 6, width: 4, depth: 2, height: 2, color: 0x5D6854 },
                { id: 'bizschool', name: 'Business School', x: 8, z: 6, width: 5, depth: 3, height: 3, color: 0x876E58 },
                { id: 'student_center', name: 'Student Center', x: 0, z: -8, width: 6, depth: 4, height: 1, color: 0x786558 },
                { id: 'general', name: 'General Building', x: -6, z: -6, width: 3, depth: 5, height: 2, color: 0x606060 },
                { id: 'arts', name: 'Arts Building', x: 10, z: 0, width: 3, depth: 2, height: 2.2, color: 0x67685D },
                { id: 'health', name: 'Health Sciences', x: 7, z: -9, width: 2.5, depth: 2.5, height: 2, color: 0x607673 }
            ];
            
            // Store building references for interaction
            window.dashboardBuildings = {};
            
            // Create all buildings
            buildings.forEach(building => {
                const buildingMesh = createDashboardBuilding(
                    building.x, 
                    building.z, 
                    building.width, 
                    building.depth, 
                    building.height, 
                    building.color, 
                    building.name,
                    building.id
                );
                
                // Store reference for interaction
                window.dashboardBuildings[building.id] = {
                    mesh: buildingMesh,
                    data: building
                };
            });
            
            // Create roads
            createDashboardRoads();
        }
        
        function createDashboardBuilding(x, z, width, depth, height, color, name, id) {
            // Create a group to hold the building and its details
            const buildingGroup = new THREE.Group();
            buildingGroup.position.set(x, 0, z);
            
            // Create the main building structure
            const geometry = new THREE.BoxGeometry(width, height, depth);
            
            // Use custom material with basic details
            const material = new THREE.MeshStandardMaterial({ 
                color: color,
                metalness: 0.1,
                roughness: 0.8
            });
            
            const building = new THREE.Mesh(geometry, material);
            building.position.y = height/2;
            
            // Store original color for hover effects
            building.userData = {
                originalColor: color,
                name: name,
                id: id
            };
            
            // Add the main building to the group
            buildingGroup.add(building);
            
            // Add windows for more detail
            addDashboardWindows(buildingGroup, width, depth, height);
            
            // Add the building group to the scene
            mapScene.add(buildingGroup);
            
            // Make building interactive
            building.callback = function() {
                selectDashboardDestination(id, name);
            };
            
            // Add to dashboard interactive objects array
            dashboardInteractiveObjects.push(building);
            
            return building;
        }
        
        function addDashboardWindows(buildingGroup, width, depth, height) {
            // Window material
            const windowMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x90BBDB, 
                metalness: 0.9,
                roughness: 0.1,
                transparent: true,
                opacity: 0.7
            });
            
            // Window dimensions
            const windowWidth = 0.3;
            const windowHeight = 0.4;
            const windowDepth = 0.05;
            
            // Front and back windows - simplified for dashboard view
            const frontWindowZ = depth / 2 + 0.01;
            
            for (let i = -1; i <= 1; i += 2) { // Just add windows on the sides for simplicity
                const x = i * (width / 3);
                
                // Front windows
                const frontWindowGeometry = new THREE.BoxGeometry(windowWidth, windowHeight, windowDepth);
                const frontWindow = new THREE.Mesh(frontWindowGeometry, windowMaterial);
                frontWindow.position.set(x, height * 0.4, frontWindowZ);
                buildingGroup.add(frontWindow);
            }
        }
        
        function createDashboardRoads() {
            const roadMaterial = new THREE.MeshStandardMaterial({ color: 0x444444 });
            
            // Main roads - same as fullscreen map
            createDashboardRoad(-15, 0, 30, 2, roadMaterial);
            createDashboardRoad(0, -15, 2, 30, roadMaterial);
            
            // Secondary roads
            createDashboardRoad(-10, 5, 10, 1.5, roadMaterial);
            createDashboardRoad(5, 5, 10, 1.5, roadMaterial);
            createDashboardRoad(-10, -7, 15, 1.5, roadMaterial);
            createDashboardRoad(7, -7, 8, 1.5, roadMaterial);
        }
        
        function createDashboardRoad(x, z, width, depth, material) {
            const roadGeo = new THREE.PlaneGeometry(width, depth);
            const road = new THREE.Mesh(roadGeo, material);
            road.rotation.x = -Math.PI / 2;
            road.position.y = -0.05;
            road.position.x = x;
            road.position.z = z;
            mapScene.add(road);
            return road;
        }
        
        function createDashboardMapControls(container) {
            // Create control container
            const controlsDiv = document.createElement('div');
            controlsDiv.className = 'dashboard-map-controls';
            controlsDiv.style.position = 'absolute';
            controlsDiv.style.top = '10px';
            controlsDiv.style.right = '10px';
            controlsDiv.style.zIndex = '10';
            container.appendChild(controlsDiv);
            
            // Create expand button to switch to full map view
            const expandBtn = document.createElement('button');
            expandBtn.className = 'map-control-btn';
            expandBtn.innerHTML = 'â›¶';
            expandBtn.title = 'Expand Map';
            expandBtn.addEventListener('click', function() {
                document.querySelector('.event-item[data-view="map-view"]').click();
            });
            controlsDiv.appendChild(expandBtn);
            
            // Create clear routes button
            const clearRoutesBtn = document.createElement('button');
            clearRoutesBtn.className = 'map-control-btn';
            clearRoutesBtn.innerHTML = 'âœ•';
            clearRoutesBtn.title = 'Clear Routes';
            clearRoutesBtn.addEventListener('click', function() {
                // Clear route
                if (dashboardCurrentRoute) {
                    // Remove the route line
                    mapScene.remove(dashboardCurrentRoute);
                    
                    // Remove any associated markers
                    if (dashboardCurrentRoute.userData && dashboardCurrentRoute.userData.markers) {
                        dashboardCurrentRoute.userData.markers.forEach(marker => {
                            mapScene.remove(marker);
                        });
                    }
                    
                    dashboardCurrentRoute = null;
                }
                
                // Reset selected building
                if (dashboardSelectedBuilding) {
                    const prevBuilding = window.dashboardBuildings[dashboardSelectedBuilding];
                    if (prevBuilding && prevBuilding.mesh) {
                        prevBuilding.mesh.material.color.setHex(prevBuilding.mesh.userData.originalColor);
                        prevBuilding.mesh.material.emissive.setHex(0x000000);
                    }
                    dashboardSelectedBuilding = null;
                }
                
                // Reset destination
                const destinationElement = document.getElementById('dashboard-selected-destination');
                if (destinationElement) {
                    destinationElement.textContent = 'Select a building';
                }
                
                // Reset distance info
                const distanceInfo = document.getElementById('dashboard-distance-info');
                if (distanceInfo) {
                    distanceInfo.textContent = '';
                }
                
                // Clear selected state from building buttons
                document.querySelectorAll('#dashboard-building-list .building-option').forEach(btn => {
                    btn.classList.remove('selected');
                });
                
                showStatusMessage('Routes cleared');
            });
            controlsDiv.appendChild(clearRoutesBtn);
        }
        
        function animateMap() {
            requestAnimationFrame(animateMap);
            mapRenderer.render(mapScene, mapCamera);
        }

        function selectDestination(buildingId, buildingName) {
            // Clear any existing routes first
            clearRoute();
            
            // Deselect previous building if any
            if (selectedBuilding) {
                const prevBuilding = window.campusBuildings[selectedBuilding];
                if (prevBuilding && prevBuilding.mesh) {
                    prevBuilding.mesh.material.color.setHex(prevBuilding.mesh.userData.originalColor);
                    prevBuilding.mesh.material.emissive.setHex(0x000000);
                }
            }
            
            // Select new building
            selectedBuilding = buildingId;
            const building = window.campusBuildings[buildingId];
            
            if (building && building.mesh) {
                // Highlight selected building
                building.mesh.material.emissive.setHex(0x1f3a93);
                
                // Show selection in UI
                showStatusMessage(`Selected destination: ${buildingName}`);
                
                // Update destination display in UI
                const destinationElement = document.getElementById('selected-destination');
                if (destinationElement) {
                    destinationElement.textContent = buildingName;
                }
                
                // Calculate and show route
                currentRoute = calculateRoute(currentUserPosition, {
                    x: building.data.x,
                    z: building.data.z
                });
                
                // Update building list selection
                const buttons = document.querySelectorAll('.building-option');
                buttons.forEach(btn => btn.classList.remove('selected'));
                
                const selectedButton = document.querySelector(`.building-option[data-building-id="${buildingId}"]`);
                if (selectedButton) {
                    selectedButton.classList.add('selected');
                }
            }
        }

        function calculateRoute(from, to) {
            // Generate a random color for this route
            const routeColor = Math.floor(Math.random() * 0xffffff);
            
            // Create a simple route (in real app this would use pathfinding)
            const points = [
                new THREE.Vector3(from.x, 0.1, from.z),
                new THREE.Vector3((from.x + to.x) / 2, 0.1, from.z),
                new THREE.Vector3((from.x + to.x) / 2, 0.1, to.z),
                new THREE.Vector3(to.x, 0.1, to.z)
            ];
            
            // Create a smooth path with a curve
            const curve = new THREE.CatmullRomCurve3(points);
            const routePoints = curve.getPoints(50);
            
            // Create line geometry for the route
            const routeGeometry = new THREE.BufferGeometry().setFromPoints(routePoints);
            
            // Create animated line material with the random color
            const routeMaterial = new THREE.LineBasicMaterial({
                color: routeColor,
                linewidth: 3
            });
            
            // Create the line and add to scene
            const routeLine = new THREE.Line(routeGeometry, routeMaterial);
            routeLine.userData = { 
                color: routeColor,
                markers: [],
                buildingId: selectedBuilding
            };
            fullscreenMapScene.add(routeLine);
            
            // Store reference to the route
            currentRoute = routeLine;
            
            // Add location marker at the start position
            const startMarker = createLocationMarker(from.x, from.z);
            routeLine.userData.markers.push(startMarker);
            
            // Add destination marker
            const endMarker = createDestinationMarker(to.x, to.z);
            routeLine.userData.markers.push(endMarker);
            
            // Calculate and show distance with more realistic walking time
            const distance = calculateDistance(from, to);
            const walkingSpeed = 1.4; // meters per second
            const walkingTimeSeconds = distance / walkingSpeed;
            const walkingTimeMinutes = Math.max(2, Math.min(10, Math.ceil(walkingTimeSeconds / 60)));
            
            const distanceInfo = document.getElementById('distance-info');
            if (distanceInfo) {
                distanceInfo.textContent = `Estimated distance: ${Math.round(distance)} m â€¢ Walking time: ${walkingTimeMinutes} min`;
            }
            
            return routeLine;
        }

        function addLandscapeElements() {
            // Add trees
            const treePositions = [
                { x: -15, z: -15 }, { x: -12, z: -10 }, { x: -18, z: -5 },
                { x: 15, z: 15 }, { x: 12, z: 10 }, { x: 18, z: 5 },
                { x: -15, z: 15 }, { x: -12, z: 10 }, { x: -18, z: 5 },
                { x: 15, z: -15 }, { x: 12, z: -10 }, { x: 18, z: -5 },
                { x: -5, z: -15 }, { x: 5, z: 15 }, { x: -5, z: 15 }, { x: 5, z: -15 }
            ];
            
            treePositions.forEach(pos => {
                createTree(pos.x, pos.z);
            });
            
            // Add benches and other elements
            const benchPositions = [
                { x: 2, z: -5, rotation: 0 },
                { x: -2, z: 3, rotation: Math.PI / 2 },
                { x: 4, z: 7, rotation: Math.PI / 4 }
            ];
            
            benchPositions.forEach(pos => {
                createBench(pos.x, pos.z, pos.rotation);
            });
            
            // Add water feature
            createWaterFeature(0, -4, 2);
        }

        function createTree(x, z) {
            const trunkGeometry = new THREE.CylinderGeometry(0.2, 0.3, 0.8, 8);
            const trunkMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.position.set(x, 0.4, z);
            
            // Create foliage
            const foliageGeometry = new THREE.ConeGeometry(1, 1.5, 8);
            const foliageMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x228B22,
                roughness: 0.8
            });
            
            const foliage = new THREE.Mesh(foliageGeometry, foliageMaterial);
            foliage.position.y = 1.3;
            trunk.add(foliage);
            
            // Add to scene
            fullscreenMapScene.add(trunk);
        }

        function createBench(x, z, rotation) {
            const benchGroup = new THREE.Group();
            benchGroup.position.set(x, 0.25, z);
            benchGroup.rotation.y = rotation;
            
            // Create bench seat
            const seatGeometry = new THREE.BoxGeometry(1.2, 0.1, 0.4);
            const seatMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
            const seat = new THREE.Mesh(seatGeometry, seatMaterial);
            seat.position.y = 0.25;
            benchGroup.add(seat);
            
            // Create bench legs
            const legGeometry = new THREE.BoxGeometry(0.1, 0.5, 0.4);
            const legMaterial = new THREE.MeshStandardMaterial({ color: 0x696969 });
            
            const leg1 = new THREE.Mesh(legGeometry, legMaterial);
            leg1.position.set(0.5, 0, 0);
            benchGroup.add(leg1);
            
            const leg2 = new THREE.Mesh(legGeometry, legMaterial);
            leg2.position.set(-0.5, 0, 0);
            benchGroup.add(leg2);
            
            // Add to scene
            fullscreenMapScene.add(benchGroup);
        }

        function createWaterFeature(x, z, radius) {
            // Create pool
            const poolGeometry = new THREE.CircleGeometry(radius, 32);
            const poolMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x4fc3f7,
                metalness: 0.9,
                roughness: 0.1,
                transparent: true,
                opacity: 0.8
            });
            
            const pool = new THREE.Mesh(poolGeometry, poolMaterial);
            pool.rotation.x = -Math.PI / 2;
            pool.position.set(x, 0.01, z);
            
            // Add to scene
            fullscreenMapScene.add(pool);
        }

        function createCampusRoads() {
            const roadMaterial = new THREE.MeshStandardMaterial({ color: 0x444444 });
            
            // Main horizontal road
            createRoad(-15, 0, 30, 2, roadMaterial);
            
            // Main vertical road
            createRoad(0, -15, 2, 30, roadMaterial);
            
            // Secondary roads
            createRoad(-10, 5, 10, 1.5, roadMaterial);
            createRoad(5, 5, 10, 1.5, roadMaterial);
            createRoad(-10, -7, 15, 1.5, roadMaterial);
            createRoad(7, -7, 8, 1.5, roadMaterial);
        }

        function createRoad(x, z, width, depth, material) {
            const roadGeo = new THREE.PlaneGeometry(width, depth);
            const road = new THREE.Mesh(roadGeo, material);
            road.rotation.x = -Math.PI / 2;
            road.position.y = -0.05;
            road.position.x = x;
            road.position.z = z;
            fullscreenMapScene.add(road);
            return road;
        }

        function createFullscreenBuilding(x, z, width, depth, height, color, name, id, style = 'modern') {
            // Create a group to hold the building and its details
            const buildingGroup = new THREE.Group();
            buildingGroup.position.set(x, 0, z);
            
            // Create layers for the building (floors)
            const numFloors = 3; // Number of floors per building
            const floorHeight = height / numFloors;
            const floors = [];
            
            // Store building data
            buildingGroup.userData = {
                name: name,
                id: id,
                floors: floors,
                isExpanded: false,
                originalPosition: new THREE.Vector3(x, 0, z),
                expandedScale: 1.5 // How much to scale when expanding
            };
            
            // Apply building style variations
            applyBuildingStyle(buildingGroup, style, width, depth, height);
            
            // Create each floor with rooms
            for (let i = 0; i < numFloors; i++) {
                // Create floor container
                const floorGroup = new THREE.Group();
                floorGroup.position.y = i * floorHeight;
                
                // Create floor base with slightly different color for each floor
                const floorColor = new THREE.Color(color);
                floorColor.r *= (1 - (i * 0.05)); // Subtle darkening for higher floors
                floorColor.g *= (1 - (i * 0.05));
                floorColor.b *= (1 - (i * 0.05));
                
                const floorGeometry = new THREE.BoxGeometry(width, floorHeight * 0.95, depth);
                
                // Create custom texture for the floor
                const floorTexture = createBuildingTexture(style, floorColor);
                
                const floorMaterial = new THREE.MeshStandardMaterial({ 
                    color: floorColor,
                    map: floorTexture,
                    metalness: 0.1 + (i * 0.05),
                    roughness: 0.8 - (i * 0.05)
                });
                
                const floorMesh = new THREE.Mesh(floorGeometry, floorMaterial);
                floorMesh.position.y = floorHeight / 2;
                floorGroup.add(floorMesh);
                
                // Store floor data
                floorMesh.userData = {
                    originalColor: floorColor,
                    name: `${name} - Floor ${i+1}`,
                    id: id,
                    floorIndex: i,
                    isVisible: true
                };
                
                // Create rooms for this floor
                createRoomsForFloor(floorGroup, width, depth, floorHeight, id, i);
                
                // Add windows for this floor
                addWindowsToFloor(floorGroup, width, depth, floorHeight);
                
                // Add the floor to the building group
                buildingGroup.add(floorGroup);
                floors.push(floorGroup);
                
                // Make floor interactive
                floorMesh.callback = function() {
                    toggleFloorVisibility(buildingGroup, i);
                };
                
                // Add to interactive objects array
                interactiveObjects.push(floorMesh);
            }
            
            // Add the building group to the scene
            fullscreenMapScene.add(buildingGroup);
            
            // Add text label above building
            createBuildingLabel(x, height + 0.8, z, name);
            
            // Make building interactive (whole building click expands/collapses)
            const mainFloorMesh = floors[0].children[0];
            mainFloorMesh.callback = function() {
                toggleBuildingExpansion(buildingGroup);
            };
            
            return mainFloorMesh;
        }

        function applyBuildingStyle(buildingGroup, style, width, depth, height) {
            const x = 0;
            const z = 0;
            
            switch (style) {
                case 'modern':
                    // Add a flat roof with details
                    const roofGeometry = new THREE.BoxGeometry(width * 1.05, height * 0.05, depth * 1.05);
                    const roofMaterial = new THREE.MeshStandardMaterial({ 
                        color: 0x333333,
                        roughness: 0.7
                    });
                    const roof = new THREE.Mesh(roofGeometry, roofMaterial);
                    roof.position.set(x, height + height * 0.025, z);
                    buildingGroup.add(roof);
                    
                    // Add glass panels on sides
                    const glassGeometry = new THREE.PlaneGeometry(width * 0.9, height * 0.7);
                    const glassMaterial = new THREE.MeshStandardMaterial({
                        color: 0x88ccee,
                        metalness: 0.9,
                        roughness: 0.1,
                        transparent: true,
                        opacity: 0.4,
                        side: THREE.DoubleSide
                    });
                    
                    // Front glass
                    const frontGlass = new THREE.Mesh(glassGeometry, glassMaterial);
                    frontGlass.position.set(x, height * 0.5, depth/2 + 0.01);
                    buildingGroup.add(frontGlass);
                    
                    // Back glass
                    const backGlass = new THREE.Mesh(glassGeometry, glassMaterial);
                    backGlass.position.set(x, height * 0.5, -depth/2 - 0.01);
                    buildingGroup.add(backGlass);
                    break;
                    
                case 'classic':
                    // Add a sloped roof
                    const classicRoofGeometry = new THREE.ConeGeometry(Math.max(width, depth) * 0.7, height * 0.4, 4);
                    const classicRoofMaterial = new THREE.MeshStandardMaterial({ 
                        color: 0x8B4513,
                        roughness: 0.8
                    });
                    const classicRoof = new THREE.Mesh(classicRoofGeometry, classicRoofMaterial);
                    classicRoof.position.set(x, height + height * 0.2, z);
                    classicRoof.rotation.y = Math.PI / 4;
                    buildingGroup.add(classicRoof);
                    
                    // Add pillars
                    const pillarGeometry = new THREE.CylinderGeometry(0.2, 0.2, height * 0.9, 12);
                    const pillarMaterial = new THREE.MeshStandardMaterial({ 
                        color: 0xEEE8AA,
                        roughness: 0.6
                    });
                    
                    const spacing = width / 3;
                    for (let i = -1; i <= 1; i++) {
                        const pillar = new THREE.Mesh(pillarGeometry, pillarMaterial);
                        pillar.position.set(i * spacing, height * 0.45, depth / 2 + 0.1);
                        buildingGroup.add(pillar);
                    }
                    break;
                    
                case 'complex':
                    // Add a central dome
                    const domeGeometry = new THREE.SphereGeometry(width * 0.3, 16, 16, 0, Math.PI * 2, 0, Math.PI * 0.5);
                    const domeMaterial = new THREE.MeshStandardMaterial({
                        color: 0xC0C0C0,
                        metalness: 0.5,
                        roughness: 0.5
                    });
                    const dome = new THREE.Mesh(domeGeometry, domeMaterial);
                    dome.position.set(x, height, z);
                    buildingGroup.add(dome);
                    
                    // Add corner towers
                    const towerGeometry = new THREE.CylinderGeometry(0.4, 0.4, height * 1.5, 8);
                    const towerMaterial = new THREE.MeshStandardMaterial({
                        color: 0xEEE8AA,
                        roughness: 0.7
                    });
                    
                    // Four corner towers
                    const cornerPositions = [
                        { x: width/2 - 0.2, z: depth/2 - 0.2 },
                        { x: width/2 - 0.2, z: -depth/2 + 0.2 },
                        { x: -width/2 + 0.2, z: depth/2 - 0.2 },
                        { x: -width/2 + 0.2, z: -depth/2 + 0.2 }
                    ];
                    
                    cornerPositions.forEach(pos => {
                        const tower = new THREE.Mesh(towerGeometry, towerMaterial);
                        tower.position.set(pos.x, height * 0.75, pos.z);
                        buildingGroup.add(tower);
                    });
                    break;
                    
                case 'residential':
                    // Add a flat roof with small details
                    const resRoofGeometry = new THREE.BoxGeometry(width, height * 0.05, depth);
                    const resRoofMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
                    const resRoof = new THREE.Mesh(resRoofGeometry, resRoofMaterial);
                    resRoof.position.set(x, height + height * 0.025, z);
                    buildingGroup.add(resRoof);
                    
                    // Add balconies
                    for (let i = -width*0.4; i <= width*0.4; i += width*0.2) {
                        const balconyGeometry = new THREE.BoxGeometry(width * 0.15, height * 0.05, depth * 0.3);
                        const balconyMaterial = new THREE.MeshStandardMaterial({ color: 0xA9A9A9 });
                        
                        const balconyFront = new THREE.Mesh(balconyGeometry, balconyMaterial);
                        balconyFront.position.set(i, height * 0.5, depth/2 + depth*0.15);
                        buildingGroup.add(balconyFront);
                        
                        const balconyBack = new THREE.Mesh(balconyGeometry, balconyMaterial);
                        balconyBack.position.set(i, height * 0.5, -depth/2 - depth*0.15);
                        buildingGroup.add(balconyBack);
                        
                        // Balcony railings
                        const railingGeometry = new THREE.BoxGeometry(width * 0.15, height * 0.15, 0.05);
                        const railingMaterial = new THREE.MeshStandardMaterial({ 
                            color: 0x333333,
                            transparent: true,
                            opacity: 0.7
                        });
                        
                        const railingFront = new THREE.Mesh(railingGeometry, railingMaterial);
                        railingFront.position.set(0, height * 0.075, depth*0.15);
                        balconyFront.add(railingFront);
                        
                        const railingBack = new THREE.Mesh(railingGeometry, railingMaterial);
                        railingBack.position.set(0, height * 0.075, -depth*0.15);
                        balconyBack.add(railingBack);
                    }
                    break;
                    
                default:
                    // Default style (no additional elements)
                    break;
            }
        }

        function createBuildingTexture(style, baseColor) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 256;
            canvas.height = 256;
            
            // Convert Three.js color to CSS color
            const r = Math.floor(baseColor.r * 255);
            const g = Math.floor(baseColor.g * 255);
            const b = Math.floor(baseColor.b * 255);
            const baseColorCSS = `rgb(${r},${g},${b})`;
            
            // Fill with base color
            ctx.fillStyle = baseColorCSS;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            switch (style) {
                case 'modern':
                    // Add horizontal window lines
                    ctx.fillStyle = 'rgba(100, 170, 220, 0.7)';
                    for (let y = 20; y < canvas.height; y += 40) {
                        ctx.fillRect(0, y, canvas.width, 15);
                    }
                    break;
                    
                case 'classic':
                    // Add brick pattern
                    ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
                    ctx.lineWidth = 1;
                    
                    // Horizontal lines
                    for (let y = 0; y < canvas.height; y += 10) {
                        ctx.beginPath();
                        ctx.moveTo(0, y);
                        ctx.lineTo(canvas.width, y);
                        ctx.stroke();
                    }
                    
                    // Vertical lines with offset for each row
                    for (let y = 0; y < canvas.height; y += 20) {
                        const offset = (y % 40 === 0) ? 0 : 10;
                        for (let x = offset; x < canvas.width; x += 20) {
                            ctx.beginPath();
                            ctx.moveTo(x, y);
                            ctx.lineTo(x, y + 10);
                            ctx.stroke();
                        }
                    }
                    break;
                    
                case 'complex':
                    // Add ornate pattern
                    ctx.strokeStyle = 'rgba(0, 0, 0, 0.2)';
                    ctx.lineWidth = 2;
                    
                    // Grid pattern
                    for (let x = 0; x < canvas.width; x += 32) {
                        ctx.beginPath();
                        ctx.moveTo(x, 0);
                        ctx.lineTo(x, canvas.height);
                        ctx.stroke();
                    }
                    
                    for (let y = 0; y < canvas.height; y += 32) {
                        ctx.beginPath();
                        ctx.moveTo(0, y);
                        ctx.lineTo(canvas.width, y);
                        ctx.stroke();
                    }
                    
                    // Add decorative elements
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
                    for (let x = 16; x < canvas.width; x += 32) {
                        for (let y = 16; y < canvas.height; y += 32) {
                            ctx.beginPath();
                            ctx.arc(x, y, 5, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }
                    break;
                    
                case 'residential':
                    // Add window pattern
                    ctx.fillStyle = 'rgba(100, 170, 220, 0.7)';
                    for (let x = 16; x < canvas.width; x += 48) {
                        for (let y = 16; y < canvas.height; y += 48) {
                            ctx.fillRect(x, y, 32, 32);
                            
                            // Window frame
                            ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                            ctx.lineWidth = 2;
                            ctx.strokeRect(x, y, 32, 32);
                            
                            // Window divider
                            ctx.beginPath();
                            ctx.moveTo(x + 16, y);
                            ctx.lineTo(x + 16, y + 32);
                            ctx.stroke();
                            
                            ctx.beginPath();
                            ctx.moveTo(x, y + 16);
                            ctx.lineTo(x + 32, y + 16);
                            ctx.stroke();
                        }
                    }
                    break;
                    
                default:
                    // Simple window pattern
                    ctx.fillStyle = 'rgba(100, 170, 220, 0.5)';
                    for (let y = 10; y < canvas.height; y += 30) {
                        for (let x = 10; x < canvas.width; x += 30) {
                            ctx.fillRect(x, y, 15, 20);
                        }
                    }
            }
            
            const texture = new THREE.CanvasTexture(canvas);
            return texture;
        }

        function createRoomsForFloor(floorGroup, width, depth, height, buildingId, floorIndex) {
            const roomMaterial = new THREE.MeshStandardMaterial({
                color: 0xffffff,
                metalness: 0.1,
                roughness: 0.8,
                transparent: true,
                opacity: 0.7
            });
            
            // Room dimensions (will vary based on building type and floor)
            const wallThickness = 0.05;
            
            // Floor-specific room layouts
            let rooms = [];
            
            // Determine room layout based on building and floor
            switch(buildingId) {
                case 'main':
                    if (floorIndex === 0) { // Ground floor - lobby and reception
                        rooms = [
                            { name: 'Lobby', x: 0, z: 0, width: width * 0.5, depth: depth * 0.6, color: 0xe1f5fe },
                            { name: 'Reception', x: -width * 0.2, z: depth * 0.2, width: width * 0.2, depth: depth * 0.2, color: 0xffecb3 },
                            { name: 'Meeting Room', x: width * 0.2, z: depth * 0.2, width: width * 0.2, depth: depth * 0.2, color: 0xe8f5e9 }
                        ];
                    } else if (floorIndex === 1) { // First floor - offices
                        rooms = [
                            { name: 'Office 101', x: -width * 0.25, z: -depth * 0.25, width: width * 0.3, depth: depth * 0.3, color: 0xffe0b2 },
                            { name: 'Office 102', x: width * 0.25, z: -depth * 0.25, width: width * 0.3, depth: depth * 0.3, color: 0xffe0b2 },
                            { name: 'Office 103', x: -width * 0.25, z: depth * 0.25, width: width * 0.3, depth: depth * 0.3, color: 0xffe0b2 },
                            { name: 'Office 104', x: width * 0.25, z: depth * 0.25, width: width * 0.3, depth: depth * 0.3, color: 0xffe0b2 }
                        ];
                    } else { // Top floor - conference rooms
                        rooms = [
                            { name: 'Conference A', x: -width * 0.2, z: 0, width: width * 0.4, depth: depth * 0.7, color: 0xd1c4e9 },
                            { name: 'Conference B', x: width * 0.2, z: 0, width: width * 0.4, depth: depth * 0.7, color: 0xd1c4e9 }
                        ];
                    }
                    break;
                    
                case 'library':
                    if (floorIndex === 0) { // Ground floor - reception and reading areas
                        rooms = [
                            { name: 'Reception', x: 0, z: depth * 0.3, width: width * 0.5, depth: depth * 0.3, color: 0xffecb3 },
                            { name: 'Reading Area', x: 0, z: -depth * 0.2, width: width * 0.8, depth: depth * 0.5, color: 0xe8f5e9 }
                        ];
                    } else if (floorIndex === 1) { // First floor - book stacks
                        rooms = [
                            { name: 'Book Stacks A', x: -width * 0.25, z: 0, width: width * 0.4, depth: depth * 0.8, color: 0xd7ccc8 },
                            { name: 'Book Stacks B', x: width * 0.25, z: 0, width: width * 0.4, depth: depth * 0.8, color: 0xd7ccc8 }
                        ];
                    } else { // Top floor - study areas
                        rooms = [
                            { name: 'Study Area 1', x: -width * 0.3, z: 0, width: width * 0.3, depth: depth * 0.6, color: 0xbbdefb },
                            { name: 'Study Area 2', x: 0, z: 0, width: width * 0.3, depth: depth * 0.6, color: 0xbbdefb },
                            { name: 'Study Area 3', x: width * 0.3, z: 0, width: width * 0.3, depth: depth * 0.6, color: 0xbbdefb }
                        ];
                    }
                    break;
                    
                case 'engineering':
                    if (floorIndex === 0) { // Ground floor - labs
                        rooms = [
                            { name: 'Lab 1', x: -width * 0.25, z: 0, width: width * 0.4, depth: depth * 0.8, color: 0xb2dfdb },
                            { name: 'Lab 2', x: width * 0.25, z: 0, width: width * 0.4, depth: depth * 0.8, color: 0xb2dfdb }
                        ];
                    } else if (floorIndex === 1) { // First floor - classrooms
                        rooms = [
                            { name: 'Classroom A', x: -width * 0.25, z: 0, width: width * 0.4, depth: depth * 0.6, color: 0xc5cae9 },
                            { name: 'Classroom B', x: width * 0.25, z: 0, width: width * 0.4, depth: depth * 0.6, color: 0xc5cae9 }
                        ];
                    } else { // Top floor - faculty offices
                        rooms = [
                            { name: 'Office 301', x: -width * 0.35, z: -depth * 0.25, width: width * 0.2, depth: depth * 0.2, color: 0xffe0b2 },
                            { name: 'Office 302', x: -width * 0.15, z: -depth * 0.25, width: width * 0.2, depth: depth * 0.2, color: 0xffe0b2 },
                            { name: 'Office 303', x: width * 0.15, z: -depth * 0.25, width: width * 0.2, depth: depth * 0.2, color: 0xffe0b2 },
                            { name: 'Office 304', x: width * 0.35, z: -depth * 0.25, width: width * 0.2, depth: depth * 0.2, color: 0xffe0b2 },
                            { name: 'Office 305', x: -width * 0.35, z: depth * 0.25, width: width * 0.2, depth: depth * 0.2, color: 0xffe0b2 },
                            { name: 'Office 306', x: -width * 0.15, z: depth * 0.25, width: width * 0.2, depth: depth * 0.2, color: 0xffe0b2 },
                            { name: 'Office 307', x: width * 0.15, z: depth * 0.25, width: width * 0.2, depth: depth * 0.2, color: 0xffe0b2 },
                            { name: 'Office 308', x: width * 0.35, z: depth * 0.25, width: width * 0.2, depth: depth * 0.2, color: 0xffe0b2 }
                        ];
                    }
                    break;
                    
                default:
                    // Default room layout for other buildings
                    if (floorIndex === 0) { // Ground floor - lobby and main areas
                        rooms = [
                            { name: 'Lobby', x: 0, z: depth * 0.3, width: width * 0.6, depth: depth * 0.3, color: 0xe1f5fe },
                            { name: 'Main Hall', x: 0, z: -depth * 0.2, width: width * 0.8, depth: depth * 0.4, color: 0xf5f5f5 }
                        ];
                    } else { // Upper floors - various rooms
                        const numRooms = 4; // 2x2 grid of rooms
                        const roomWidth = width * 0.4;
                        const roomDepth = depth * 0.4;
                        
                        for (let row = 0; row < 2; row++) {
                            for (let col = 0; col < 2; col++) {
                                const roomX = (col === 0 ? -1 : 1) * (width * 0.2);
                                const roomZ = (row === 0 ? -1 : 1) * (depth * 0.2);
                                const roomNum = row * 2 + col + 1;
                                
                                rooms.push({
                                    name: `Room ${floorIndex}${roomNum}`,
                                    x: roomX,
                                    z: roomZ,
                                    width: roomWidth,
                                    depth: roomDepth,
                                    color: 0xf5f5f5
                                });
                            }
                        }
                    }
            }
            
            // Create room meshes
            rooms.forEach(room => {
                const roomGeometry = new THREE.BoxGeometry(room.width, height * 0.7, room.depth);
                const roomMat = new THREE.MeshStandardMaterial({
                    color: room.color,
                    transparent: true,
                    opacity: 0.7,
                    metalness: 0.1,
                    roughness: 0.8
                });
                
                const roomMesh = new THREE.Mesh(roomGeometry, roomMat);
                roomMesh.position.set(room.x, height * 0.35, room.z);
                
                // Create a frame for the room outline
                const edgesGeometry = new THREE.EdgesGeometry(roomGeometry);
                const edgesMaterial = new THREE.LineBasicMaterial({ 
                    color: 0x000000,
                    linewidth: 1
                });
                const edges = new THREE.LineSegments(edgesGeometry, edgesMaterial);
                roomMesh.add(edges);
                
                // Add room label
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.width = 128;
                canvas.height = 64;
                
                context.fillStyle = 'rgba(0, 0, 0, 0.7)';
                context.fillRect(0, 0, canvas.width, canvas.height);
                
                context.font = 'bold 14px Arial';
                context.fillStyle = 'white';
                context.textAlign = 'center';
                context.textBaseline = 'middle';
                context.fillText(room.name, canvas.width / 2, canvas.height / 2);
                
                const texture = new THREE.CanvasTexture(canvas);
                const labelMaterial = new THREE.SpriteMaterial({ 
                    map: texture,
                    transparent: true,
                    opacity: 0.9
                });
                
                const label = new THREE.Sprite(labelMaterial);
                label.position.set(0, height * 0.4, 0);
                label.scale.set(1.2, 0.6, 1);
                roomMesh.add(label);
                
                // Make rooms hidden by default
                roomMesh.visible = false;
                
                // Store room data and add to floor
                roomMesh.userData = {
                    name: room.name,
                    type: 'room',
                    floor: floorIndex
                };
                
                floorGroup.add(roomMesh);
            });
        }

        function addWindowsToFloor(floorGroup, width, depth, height) {
            // Window material
            const windowMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x90BBDB, 
                metalness: 0.9,
                roughness: 0.1,
                transparent: true,
                opacity: 0.7
            });
            
            // Window dimensions
            const windowWidth = 0.3;
            const windowHeight = 0.4;
            const windowDepth = 0.05;
            
            const frontWindowZ = depth / 2 + 0.01;
            const backWindowZ = -depth / 2 - 0.01;
            
            // Add windows on all sides
            for (let i = -1; i <= 1; i += 0.5) {
                // Skip center window on front side
                if (i !== 0) {
                    // Front windows
                    const frontWindowGeometry = new THREE.BoxGeometry(windowWidth, windowHeight, windowDepth);
                    const frontWindow = new THREE.Mesh(frontWindowGeometry, windowMaterial);
                    frontWindow.position.set(i * (width * 0.3), height * 0.5, frontWindowZ);
                    floorGroup.add(frontWindow);
                    
                    // Back windows
                    const backWindowGeometry = new THREE.BoxGeometry(windowWidth, windowHeight, windowDepth);
                    const backWindow = new THREE.Mesh(backWindowGeometry, windowMaterial);
                    backWindow.position.set(i * (width * 0.3), height * 0.5, backWindowZ);
                    floorGroup.add(backWindow);
                }
                
                // Side windows (only on sides)
                if (i !== 0) {
                    const rightWindowX = width / 2 + 0.01;
                    const leftWindowX = -width / 2 - 0.01;
                    
                    // Right windows
                    const rightWindowGeometry = new THREE.BoxGeometry(windowDepth, windowHeight, windowWidth);
                    const rightWindow = new THREE.Mesh(rightWindowGeometry, windowMaterial);
                    rightWindow.position.set(rightWindowX, height * 0.5, i * (depth * 0.3));
                    floorGroup.add(rightWindow);
                    
                    // Left windows
                    const leftWindowGeometry = new THREE.BoxGeometry(windowDepth, windowHeight, windowWidth);
                    const leftWindow = new THREE.Mesh(leftWindowGeometry, windowMaterial);
                    leftWindow.position.set(leftWindowX, height * 0.5, i * (depth * 0.3));
                    floorGroup.add(leftWindow);
                }
            }
        }

        // Event Details Modal Functions
        function showEventDetails(event) {
            // Create modal if it doesn't exist
            let modal = document.getElementById('event-details-modal');
            if (!modal) {
                modal = createEventDetailsModal();
                document.body.appendChild(modal);
            }

            // Populate modal with event data
            populateEventModal(modal, event);
            
            // Show the modal
            modal.style.display = 'flex';
            
            // Add event listener to close modal when clicking outside
            modal.addEventListener('click', function(e) {
                if (e.target === modal) {
                    hideEventDetailsModal();
                }
            });

            // Add keyboard listener to close modal with Escape key
            document.addEventListener('keydown', function escapeHandler(e) {
                if (e.key === 'Escape') {
                    hideEventDetailsModal();
                    document.removeEventListener('keydown', escapeHandler);
                }
            });
        }

        function createEventDetailsModal() {
            const modal = document.createElement('div');
            modal.id = 'event-details-modal';
            modal.className = 'modal-overlay';
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background-color: rgba(0, 0, 0, 0.7);
                display: none;
                align-items: center;
                justify-content: center;
                z-index: 2000;
            `;

            const modalContent = document.createElement('div');
            modalContent.className = 'event-modal-content';
            modalContent.style.cssText = `
                background-color: #2a2a2a;
                padding: 2rem;
                border-radius: 0.5rem;
                box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
                width: 100%;
                max-width: 28rem;
                color: #fff;
                position: relative;
                max-height: 80vh;
                overflow-y: auto;
            `;

            modalContent.innerHTML = `
                <button class="modal-close-btn" style="
                    position: absolute;
                    top: 10px;
                    right: 10px;
                    background: none;
                    border: none;
                    color: #aaa;
                    font-size: 1.5rem;
                    cursor: pointer;
                    padding: 0;
                    width: 30px;
                    height: 30px;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                ">&times;</button>
                
                <div class="event-header" style="margin-bottom: 1.5rem;">
                    <h2 id="modal-event-title" style="margin: 0 0 0.5rem 0; font-size: 1.5rem; font-weight: bold;"></h2>
                    <span id="modal-event-type" style="
                        padding: 0.25rem 0.75rem;
                        border-radius: 0.375rem;
                        font-size: 0.75rem;
                        font-weight: 600;
                        display: inline-block;
                    "></span>
                </div>
                
                <div class="event-details" style="space-y: 1rem;">
                    <div class="detail-row" style="margin-bottom: 1rem;">
                        <strong style="display: block; margin-bottom: 0.25rem; color: #ccc;">Course:</strong>
                        <span id="modal-course-info"></span>
                    </div>
                    
                    <div class="detail-row" style="margin-bottom: 1rem;">
                        <strong style="display: block; margin-bottom: 0.25rem; color: #ccc;">Location:</strong>
                        <span id="modal-location-info"></span>
                    </div>
                    
                    <div class="detail-row" style="margin-bottom: 1rem;">
                        <strong style="display: block; margin-bottom: 0.25rem; color: #ccc;">Time:</strong>
                        <span id="modal-time-info"></span>
                    </div>
                    
                    <div class="detail-row" style="margin-bottom: 1rem;">
                        <strong style="display: block; margin-bottom: 0.25rem; color: #ccc;">Lecturer:</strong>
                        <span id="modal-lecturer-info"></span>
                    </div>
                </div>
                
                <div class="modal-actions" style="margin-top: 1.5rem; display: flex; gap: 0.5rem;">
                    <button id="modal-navigate-btn" style="
                        flex: 1;
                        background-color: #5473e8;
                        color: white;
                        border: none;
                        padding: 0.75rem 1rem;
                        border-radius: 0.375rem;
                        cursor: pointer;
                        font-weight: 600;
                    ">Navigate</button>
                    <button id="modal-close-btn" style="
                        flex: 1;
                        background-color: #444;
                        color: white;
                        border: none;
                        padding: 0.75rem 1rem;
                        border-radius: 0.375rem;
                        cursor: pointer;
                        font-weight: 600;
                    ">Close</button>
                </div>
            `;

            modal.appendChild(modalContent);

            // Add event listeners for closing the modal
            modalContent.querySelector('.modal-close-btn').addEventListener('click', hideEventDetailsModal);
            modalContent.querySelector('#modal-close-btn').addEventListener('click', hideEventDetailsModal);

            return modal;
        }

        function populateEventModal(modal, event) {
            const title = modal.querySelector('#modal-event-title');
            const type = modal.querySelector('#modal-event-type');
            const course = modal.querySelector('#modal-course-info');
            const location = modal.querySelector('#modal-location-info');
            const time = modal.querySelector('#modal-time-info');
            const lecturer = modal.querySelector('#modal-lecturer-info');
            const navigateBtn = modal.querySelector('#modal-navigate-btn');

            // Set title and clear any previous urgent badges
            title.innerHTML = '';
            title.textContent = event.title || 'Untitled Event';

            // Set event type with appropriate styling
            const eventTypeLabel = event.event_type === 'exam' ? 'EXAM' : 'CLASS';
            const typeColor = event.event_type === 'exam' ? '#f97316' : '#3b82f6';
            type.textContent = eventTypeLabel;
            type.style.backgroundColor = typeColor;
            type.style.color = 'white';

            // Set course info
            const courseCode = event.course && event.course.code ? event.course.code : 'N/A';
            const courseName = event.course && event.course.name ? event.course.name : '';
            course.textContent = courseName ? `${courseCode} - ${courseName}` : courseCode;

            // Set location
            const roomInfo = event.room ? 
                `${event.room.building || ''} ${event.room.number || ''}`.trim() : 
                'TBA';
            location.textContent = roomInfo;

            // Set time
            const startTime = new Date(event.start_time);
            const endTime = new Date(event.end_time);
            const dateOptions = { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' };
            const timeOptions = { hour: '2-digit', minute: '2-digit' };
            time.textContent = `${startTime.toLocaleDateString(undefined, dateOptions)} â€¢ ${startTime.toLocaleTimeString(undefined, timeOptions)} - ${endTime.toLocaleTimeString(undefined, timeOptions)}`;

            // Set lecturer
            lecturer.textContent = event.lecturer || 'No lecturer assigned';

            // Handle navigate button
            if (event.room) {
                navigateBtn.style.display = 'block';
                navigateBtn.onclick = function() {
                    hideEventDetailsModal();
                    // Navigate to the building if we have room information
                    const buildingMap = {
                        'ENG': 'engineering',
                        'SCI': 'science', 
                        'LIB': 'library',
                        'BUS': 'bizschool',
                        'ARTS': 'arts',
                        'HSB': 'health'
                    };
                    const buildingId = buildingMap[event.room.building] || 'main';
                    navigateToBuilding(buildingId);
                };
            } else {
                navigateBtn.style.display = 'none';
            }

            // Add urgent styling if needed
            if (event.is_urgent) {
                const urgentBadge = document.createElement('span');
                urgentBadge.style.cssText = `
                    background-color: #ef4444;
                    color: white;
                    padding: 0.25rem 0.5rem;
                    border-radius: 0.375rem;
                    font-size: 0.75rem;
                    font-weight: 600;
                    margin-left: 0.5rem;
                `;
                urgentBadge.textContent = 'URGENT';
                title.appendChild(urgentBadge);
            }
        }

        function hideEventDetailsModal() {
            const modal = document.getElementById('event-details-modal');
            if (modal) {
                modal.style.display = 'none';
            }
        }
    </script>
</body>

</html> 
